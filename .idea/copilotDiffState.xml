<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/build.gradle.kts" />
              <option name="originalContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;    implementation(project(&quot;:data:model&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;    implementation(libs.androidx.foundation.layout)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;&#10;    // compose shape&#10;    implementation(&quot;androidx.graphics:graphics-shapes:1.0.1&quot;)&#10;}" />
              <option name="updatedContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;    implementation(project(&quot;:data:model&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;    implementation(libs.androidx.foundation.layout)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;&#10;    // compose shape&#10;    implementation(&quot;androidx.graphics:graphics-shapes:1.0.1&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * Y축 위치를 나타내는 열거형 클래스&#10; */&#10;enum class YAxisPosition {&#10;    LEFT,   // 왼쪽&#10;    RIGHT   // 오른쪽&#10;}&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT, drawLabels: Boolean = true) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            // Convert chart-relative Y to canvas coordinates&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = metrics.paddingX // 왼쪽 Y축까지&#10;            val gridEnd = when (yAxisPosition) {&#10;                YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                YAxisPosition.LEFT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            // only draw labels when drawLabels = true&#10;            if (drawLabels) {&#10;                val labelText = formatTickLabel(yVal)&#10;&#10;                // Y축 레이블 위치를 yAxisPosition에 따라 결정&#10;                val labelX = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; yAxisX + 20f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                    YAxisPosition.LEFT -&gt; 20f // 기본값: 왼쪽 위치&#10;                }&#10;&#10;                // Y축 레이블 정렬을 yAxisPosition에 따라 결정&#10;                val textAlign = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; android.graphics.Paint.Align.LEFT // 오른쪽 Y축일 때는 왼쪽 정렬&#10;                    YAxisPosition.LEFT -&gt; android.graphics.Paint.Align.RIGHT // 왼쪽 Y축일 때는 오른쪽 정렬&#10;                }&#10;&#10;                drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                    labelText,&#10;                    labelX,&#10;                    y + 10f,&#10;                    android.graphics.Paint().apply {&#10;                        color = android.graphics.Color.DKGRAY&#10;                        textSize = 28f&#10;                        this.textAlign = textAlign&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.paddingY + metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT) {&#10;        // Y축 라인 위치를 yAxisPosition에 따라 결정&#10;        val axisStartX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, metrics.paddingY),&#10;            end = Offset(axisStartX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    fun drawYAxisStandalone(&#10;        drawScope: DrawScope,&#10;        metrics: ChartMath.ChartMetrics,&#10;        yAxisPosition: YAxisPosition,&#10;        paneWidthPx: Float,&#10;        labelTextSizePx: Float = 28f&#10;    ) {&#10;        // Axis X anchored to the pane edge (1px in from the edge)&#10;        val axisX = if (yAxisPosition == YAxisPosition.RIGHT) paneWidthPx - 0.5f else 0.5f&#10;&#10;        // Axis line&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisX, metrics.paddingY),&#10;            end = Offset(axisX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;&#10;        // Ticks &amp; labels&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // small tick mark&#10;            val tickLen = 8f&#10;            val tickStartX = if (yAxisPosition == YAxisPosition.RIGHT) axisX else axisX&#10;            val tickEndX = if (yAxisPosition == YAxisPosition.RIGHT) axisX - tickLen else axisX + tickLen&#10;            drawScope.drawLine(&#10;                color = Color.DarkGray,&#10;                start = Offset(tickStartX, y),&#10;                end = Offset(tickEndX, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            val label = formatTickLabel(yVal)&#10;            val paint = android.graphics.Paint().apply {&#10;                isAntiAlias = true&#10;                color = android.graphics.Color.DKGRAY&#10;                textSize = labelTextSizePx&#10;                textAlign = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                    android.graphics.Paint.Align.LEFT else android.graphics.Paint.Align.RIGHT&#10;            }&#10;            val labelX = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                axisX + 10f else axisX - 10f&#10;&#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(label, labelX, y + 10f, paint)&#10;        }&#10;    }&#10;&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * Y축 위치를 나타내는 열거형 클래스&#10; */&#10;enum class YAxisPosition {&#10;    LEFT,   // 왼쪽&#10;    RIGHT   // 오른쪽&#10;}&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT, drawLabels: Boolean = true) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            // Convert chart-relative Y to canvas coordinates&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = metrics.paddingX // 왼쪽 Y축까지&#10;            val gridEnd = when (yAxisPosition) {&#10;                YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                YAxisPosition.LEFT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            // only draw labels when drawLabels = true&#10;            if (drawLabels) {&#10;                val labelText = formatTickLabel(yVal)&#10;&#10;                // Y축 레이블 위치를 yAxisPosition에 따라 결정&#10;                val labelX = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; yAxisX + 20f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                    YAxisPosition.LEFT -&gt; 20f // 기본값: 왼쪽 위치&#10;                }&#10;&#10;                // Y축 레이블 정렬을 yAxisPosition에 따라 결정&#10;                val textAlign = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; android.graphics.Paint.Align.LEFT // 오른쪽 Y축일 때는 왼쪽 정렬&#10;                    YAxisPosition.LEFT -&gt; android.graphics.Paint.Align.RIGHT // 왼쪽 Y축일 때는 오른쪽 정렬&#10;                }&#10;&#10;                drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                    labelText,&#10;                    labelX,&#10;                    y + 10f,&#10;                    android.graphics.Paint().apply {&#10;                        color = android.graphics.Color.DKGRAY&#10;                        textSize = 28f&#10;                        this.textAlign = textAlign&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.paddingY + metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT) {&#10;        // Y축 라인 위치를 yAxisPosition에 따라 결정&#10;        val axisStartX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, metrics.paddingY),&#10;            end = Offset(axisStartX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    fun drawYAxisStandalone(&#10;        drawScope: DrawScope,&#10;        metrics: ChartMath.ChartMetrics,&#10;        yAxisPosition: YAxisPosition,&#10;        paneWidthPx: Float,&#10;        labelTextSizePx: Float = 28f&#10;    ) {&#10;        // Axis X anchored to the pane edge (1px in from the edge)&#10;        val axisX = if (yAxisPosition == YAxisPosition.RIGHT) paneWidthPx - 0.5f else 0.5f&#10;&#10;        // Axis line&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisX, metrics.paddingY),&#10;            end = Offset(axisX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;&#10;        // Ticks &amp; labels&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // small tick mark&#10;            val tickLen = 8f&#10;            val tickStartX = if (yAxisPosition == YAxisPosition.RIGHT) axisX else axisX&#10;            val tickEndX = if (yAxisPosition == YAxisPosition.RIGHT) axisX - tickLen else axisX + tickLen&#10;            drawScope.drawLine(&#10;                color = Color.DarkGray,&#10;                start = Offset(tickStartX, y),&#10;                end = Offset(tickEndX, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            val label = formatTickLabel(yVal)&#10;            val paint = android.graphics.Paint().apply {&#10;                isAntiAlias = true&#10;                color = android.graphics.Color.DKGRAY&#10;                textSize = labelTextSizePx&#10;                textAlign = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                    android.graphics.Paint.Align.LEFT else android.graphics.Paint.Align.RIGHT&#10;            }&#10;            val labelX = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                axisX + 10f else axisX - 10f&#10;&#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(label, labelX, y + 10f, paint)&#10;        }&#10;    }&#10;&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/SleepStageChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/SleepStageChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.chartMath.SleepStageChartMath&#10;&#10;object SleepStageChartDraw {&#10;    &#10;    /**&#10;     * 수평 바 차트의 바들을 Composable로 생성합니다.&#10;     * 수면 단계 차트와 같은 수평 바 차트에 사용됩니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param minValues 바의 최소값 목록 (X축 방향의 시작값)&#10;     * @param maxValues 바의 최대값 목록 (X축 방향의 끝값)&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상 (단일 바용)&#10;     * @param barHeightRatio 바 높이 배수 (기본값: 0.8f)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 툴팁 텍스트)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     * @param showTooltipForIndex 외부에서 제어되는 툴팁 표시 인덱스 (null이면 표시 안함)&#10;     * @param isTouchArea true이면 터치 영역용 (투명, 전체 너비, 상호작용 가능), false이면 일반 바 (기본값: false)&#10;     * @param customTooltipText 커스텀 툴팁 텍스트 목록 (null이면 기본 툴팁 사용)&#10;     * @param showLabel 라벨 표시 여부 (기본값: false)&#10;     * @param unit 단위 (기본값: &quot;&quot;)&#10;     */&#10;    @Composable&#10;    fun HorizontalBarMarker(&#10;        data: List&lt;BaseChartPoint&gt;,&#10;        minValues: List&lt;Float&gt;,&#10;        maxValues: List&lt;Float&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        color: Color = Color.Black,&#10;        barHeightRatio: Float = 0.5f,&#10;        interactive: Boolean = true,&#10;        onBarClick: ((Int, String) -&gt; Unit)? = null,&#10;        chartType: ChartType,&#10;        showTooltipForIndex: Int? = null,&#10;        isTouchArea: Boolean = false,&#10;        customTooltipText: List&lt;String&gt;? = null,&#10;//        showLabel: Boolean = false,  &lt;- SleepStage에서는 필요없음, ProgressBar에서 사용&#10;        unit: String = &quot;&quot;,&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        // 터치 영역용인 경우 자동으로 파라미터 설정&#10;        val actualBarHeightRatio = if (isTouchArea) 1.0f else barHeightRatio&#10;        val actualInteractive = if (isTouchArea) true else interactive&#10;&#10;        val dataSize = maxOf(minValues.size, maxValues.size)&#10;&#10;        // 클릭된 바의 인덱스를 관리하는 상태 변수&#10;        var clickedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;        // 툴팁 정보 저장 변수&#10;        var tooltipOffset: Offset? = null&#10;        var tooltipData: BaseChartPoint? = null&#10;&#10;        (0 until dataSize).forEach { index -&gt;&#10;            // 값 추출&#10;            val minValue = minValues.getOrNull(index) ?: 0f&#10;            val maxValue = maxValues.getOrNull(index) ?: 0f&#10;&#10;            // tooltipText is only used for onBarClick callback&#10;            val tooltipText = customTooltipText?.getOrNull(index) ?: &quot;Sleep Stage&quot;&#10;&#10;            // 바 너비와 위치 계산 (수평이므로 X축 방향으로 계산)&#10;            val (barWidth, barX) = if (isTouchArea) {&#10;                // 전체 차트 너비 사용 (터치 영역용)&#10;                Pair(metrics.chartWidth, metrics.paddingX)&#10;            } else {&#10;                // minValue에서 maxValue까지의 바 계산 (X축 방향)&#10;                val xMinScreen = ((minValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val xMaxScreen = ((maxValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val width = xMaxScreen - xMinScreen&#10;                // Add paddingX to position bars correctly within the chart area&#10;                Pair(width, metrics.paddingX + xMinScreen)&#10;            }&#10;&#10;            // 바 Y 위치 계산 (수평이므로 Y축은 sleep stage ordinal 기반)&#10;            val sleepStageOrdinal = data.getOrNull(index)?.x?.toInt() ?: 0&#10;            val totalSleepStages = 4 // AWAKE, REM, LIGHT, DEEP&#10;            val spacing = metrics.chartHeight / totalSleepStages&#10;            val barHeight = spacing * actualBarHeightRatio&#10;            val barY = metrics.paddingY + sleepStageOrdinal * spacing + (spacing - barHeight) / 2f&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val barXDp = with(density) { barX.toDp() }&#10;            val barYDp = with(density) { barY.toDp() }&#10;            val barWidthDp = with(density) { barWidth.toDp() }&#10;            val barHeightDp = with(density) { barHeight.toDp() }&#10;&#10;            // 툴팁 표시 여부 결정&#10;            val shouldShowTooltip = when {&#10;                isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                chartType in listOf(ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                    if (actualInteractive) {&#10;                        clickedBarIndex == index&#10;                    } else {&#10;                        showTooltipForIndex == index&#10;                    }&#10;                }&#10;                else -&gt; false // 다른 차트 타입에서는 툴팁 표시 안함&#10;            }&#10;&#10;            if (shouldShowTooltip) {&#10;                tooltipData = data[index]&#10;                tooltipOffset = Offset(barX, barY)&#10;            }&#10;&#10;            val actualColor = if (isTouchArea) {&#10;                Color.Transparent // 터치 영역용은 투명&#10;            } else {&#10;                if (actualInteractive) {&#10;                    if (clickedBarIndex == index || clickedBarIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                } else {&#10;                    if (showTooltipForIndex == index || showTooltipForIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                }&#10;            }&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .offset(x = barXDp, y = barYDp)&#10;                    .size(width = barWidthDp, height = barHeightDp)&#10;                    .background(color = actualColor)&#10;                    .clickable {&#10;                        if (actualInteractive) {&#10;                            // 클릭된 바 인덱스 토글&#10;                            clickedBarIndex = if (clickedBarIndex == index) null else index&#10;                            // 외부 클릭 이벤트 처리&#10;                            onBarClick?.invoke(index, tooltipText)&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;        &#10;        // 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;        if (tooltipData != null &amp;&amp; tooltipOffset != null) {&#10;            val xDp = with(density) { tooltipOffset.x.toDp() }&#10;            val yDp = with(density) { tooltipOffset.y.toDp() }&#10;            &#10;            // Generate custom tooltip text for sleep stage charts&#10;            val customTooltipText = if (tooltipData is RangeChartPoint) {&#10;                val sleepStageOrdinal = tooltipData.x.toInt()&#10;                val sleepStageName = when (sleepStageOrdinal) {&#10;                    0 -&gt; &quot;Awake&quot;&#10;                    1 -&gt; &quot;REM&quot;&#10;                    2 -&gt; &quot;Light&quot;&#10;                    3 -&gt; &quot;Deep&quot;&#10;                    else -&gt; &quot;Unknown&quot;&#10;                }&#10;                val startTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.minPoint.y)&#10;                val endTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.maxPoint.y)&#10;                &quot;$startTime - $endTime&quot;&#10;            } else null&#10;            &#10;            ChartTooltip(&#10;                chartPoint = tooltipData,&#10;                unit = unit,&#10;                customText = customTooltipText,&#10;                modifier = Modifier.offset(x = xDp, y = yDp - 80.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.chartMath.SleepStageChartMath&#10;&#10;object SleepStageChartDraw {&#10;    &#10;    /**&#10;     * 수평 바 차트의 바들을 Composable로 생성합니다.&#10;     * 수면 단계 차트와 같은 수평 바 차트에 사용됩니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param minValues 바의 최소값 목록 (X축 방향의 시작값)&#10;     * @param maxValues 바의 최대값 목록 (X축 방향의 끝값)&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상 (단일 바용)&#10;     * @param barHeightRatio 바 높이 배수 (기본값: 0.8f)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 툴팁 텍스트)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     * @param showTooltipForIndex 외부에서 제어되는 툴팁 표시 인덱스 (null이면 표시 안함)&#10;     * @param isTouchArea true이면 터치 영역용 (투명, 전체 너비, 상호작용 가능), false이면 일반 바 (기본값: false)&#10;     * @param customTooltipText 커스텀 툴팁 텍스트 목록 (null이면 기본 툴팁 사용)&#10;     * @param showLabel 라벨 표시 여부 (기본값: false)&#10;     * @param unit 단위 (기본값: &quot;&quot;)&#10;     */&#10;    @Composable&#10;    fun HorizontalBarMarker(&#10;        data: List&lt;BaseChartPoint&gt;,&#10;        minValues: List&lt;Float&gt;,&#10;        maxValues: List&lt;Float&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        color: Color = Color.Black,&#10;        barHeightRatio: Float = 0.5f,&#10;        interactive: Boolean = true,&#10;        onBarClick: ((Int, String) -&gt; Unit)? = null,&#10;        chartType: ChartType,&#10;        showTooltipForIndex: Int? = null,&#10;        isTouchArea: Boolean = false,&#10;        customTooltipText: List&lt;String&gt;? = null,&#10;//        showLabel: Boolean = false,  &lt;- SleepStage에서는 필요없음, ProgressBar에서 사용&#10;        unit: String = &quot;&quot;,&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        // 터치 영역용인 경우 자동으로 파라미터 설정&#10;        val actualBarHeightRatio = if (isTouchArea) 1.0f else barHeightRatio&#10;        val actualInteractive = if (isTouchArea) true else interactive&#10;&#10;        val dataSize = maxOf(minValues.size, maxValues.size)&#10;&#10;        // 클릭된 바의 인덱스를 관리하는 상태 변수&#10;        var clickedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;        // 툴팁 정보 저장 변수&#10;        var tooltipOffset: Offset? = null&#10;        var tooltipData: BaseChartPoint? = null&#10;&#10;        (0 until dataSize).forEach { index -&gt;&#10;            // 값 추출&#10;            val minValue = minValues.getOrNull(index) ?: 0f&#10;            val maxValue = maxValues.getOrNull(index) ?: 0f&#10;&#10;            // tooltipText is only used for onBarClick callback&#10;            val tooltipText = customTooltipText?.getOrNull(index) ?: &quot;Sleep Stage&quot;&#10;&#10;            // 바 너비와 위치 계산 (수평이므로 X축 방향으로 계산)&#10;            val (barWidth, barX) = if (isTouchArea) {&#10;                // 전체 차트 너비 사용 (터치 영역용)&#10;                Pair(metrics.chartWidth, metrics.paddingX)&#10;            } else {&#10;                // minValue에서 maxValue까지의 바 계산 (X축 방향)&#10;                val xMinScreen = ((minValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val xMaxScreen = ((maxValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val width = xMaxScreen - xMinScreen&#10;                // Add paddingX to position bars correctly within the chart area&#10;                Pair(width, metrics.paddingX + xMinScreen)&#10;            }&#10;&#10;            // 바 Y 위치 계산 (수평이므로 Y축은 sleep stage ordinal 기반)&#10;            val sleepStageOrdinal = data.getOrNull(index)?.x?.toInt() ?: 0&#10;            val totalSleepStages = 4 // AWAKE, REM, LIGHT, DEEP&#10;            val spacing = metrics.chartHeight / totalSleepStages&#10;            val barHeight = spacing * actualBarHeightRatio&#10;            val barY = metrics.paddingY + sleepStageOrdinal * spacing + (spacing - barHeight) / 2f&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val barXDp = with(density) { barX.toDp() }&#10;            val barYDp = with(density) { barY.toDp() }&#10;            val barWidthDp = with(density) { barWidth.toDp() }&#10;            val barHeightDp = with(density) { barHeight.toDp() }&#10;&#10;            // 툴팁 표시 여부 결정&#10;            val shouldShowTooltip = when {&#10;                isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                chartType in listOf(ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                    if (actualInteractive) {&#10;                        clickedBarIndex == index&#10;                    } else {&#10;                        showTooltipForIndex == index&#10;                    }&#10;                }&#10;                else -&gt; false // 다른 차트 타입에서는 툴팁 표시 안함&#10;            }&#10;&#10;            if (shouldShowTooltip) {&#10;                tooltipData = data[index]&#10;                tooltipOffset = Offset(barX, barY)&#10;            }&#10;&#10;            val actualColor = if (isTouchArea) {&#10;                Color.Transparent // 터치 영역용은 투명&#10;            } else {&#10;                if (actualInteractive) {&#10;                    if (clickedBarIndex == index || clickedBarIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                } else {&#10;                    if (showTooltipForIndex == index || showTooltipForIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                }&#10;            }&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .offset(x = barXDp, y = barYDp)&#10;                    .size(width = barWidthDp, height = barHeightDp)&#10;                    .background(color = actualColor)&#10;                    .clickable {&#10;                        if (actualInteractive) {&#10;                            // 클릭된 바 인덱스 토글&#10;                            clickedBarIndex = if (clickedBarIndex == index) null else index&#10;                            // 외부 클릭 이벤트 처리&#10;                            onBarClick?.invoke(index, tooltipText)&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;        &#10;        // 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;        if (tooltipData != null &amp;&amp; tooltipOffset != null) {&#10;            val xDp = with(density) { tooltipOffset.x.toDp() }&#10;            val yDp = with(density) { tooltipOffset.y.toDp() }&#10;            &#10;            // Generate custom tooltip text for sleep stage charts&#10;            val customTooltipText = if (tooltipData is RangeChartPoint) {&#10;                val sleepStageOrdinal = tooltipData.x.toInt()&#10;                val sleepStageName = when (sleepStageOrdinal) {&#10;                    0 -&gt; &quot;Awake&quot;&#10;                    1 -&gt; &quot;REM&quot;&#10;                    2 -&gt; &quot;Light&quot;&#10;                    3 -&gt; &quot;Deep&quot;&#10;                    else -&gt; &quot;Unknown&quot;&#10;                }&#10;                val startTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.minPoint.y)&#10;                val endTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.maxPoint.y)&#10;                &quot;$startTime - $endTime&quot;&#10;            } else null&#10;            &#10;            ChartTooltip(&#10;                chartPoint = tooltipData,&#10;                unit = unit,&#10;                customText = customTooltipText,&#10;                modifier = Modifier.offset(x = xDp, y = yDp - 80.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/provider/src/main/java/com/hdil/saluschart/data/provider/SampleDataProvider.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/provider/src/main/java/com/hdil/saluschart/data/provider/SampleDataProvider.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.data.provider&#10;&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ProgressChartPoint&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;import com.hdil.saluschart.core.transform.transform&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.util.AggregationType&#10;import com.hdil.saluschart.data.model.model.BloodPressure&#10;import com.hdil.saluschart.data.model.model.BodyFat&#10;import com.hdil.saluschart.data.model.model.Mass&#10;import com.hdil.saluschart.data.model.model.SleepSession&#10;import com.hdil.saluschart.data.model.model.SleepStage&#10;import com.hdil.saluschart.data.model.model.StepCount&#10;import com.hdil.saluschart.data.model.model.Weight&#10;import com.hdil.saluschart.ui.compose.charts.CalendarEntry&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.YearMonth&#10;import java.time.*&#10;import kotlin.random.Random&#10;import kotlin.math.roundToInt&#10;&#10;&#10;/**&#10; * Provides sample data for demonstration and testing purposes.&#10; * All sample data is organized here for better maintainability.&#10; */&#10;object SampleDataProvider {&#10;    &#10;    // Basic sample data arrays&#10;    val sampleData = listOf(10f, 25f, 40f, 20f, 35f, 55f, 45f)&#10;    val sampleData2 = listOf(5f, 15f, 60f, 45f, 35f, 25f, 10f)&#10;    val sampleData3 = listOf(8f, 22f, 10f, 40f, 18f, 32f, 12f)&#10;    val sampleData4 = listOf(10f, 25f, 40f, 20f, 35f, 55f, 45f, 5f, 15f, 60f, 45f, 35f, 25f, 10f, 8f, 22f, 10f, 40f, 18f, 32f, 12f)&#10;    &#10;    // Week days labels&#10;    val weekDays = listOf(&quot;월&quot;, &quot;화&quot;, &quot;수&quot;, &quot;목&quot;, &quot;금&quot;, &quot;토&quot;, &quot;일&quot;)&#10;    &#10;    // Nutrition segment labels for stacked charts&#10;    val segmentLabels = listOf(&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;)&#10;&#10;    /**&#10;     * Sample step count health data spanning two days with 30-minute intervals&#10;     */&#10;//    fun getStepCountData(): List&lt;StepCount&gt; = listOf(&#10;//        StepCount(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), Instant.parse(&quot;2025-05-04T08:30:00Z&quot;), 43),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T09:00:00Z&quot;), Instant.parse(&quot;2025-05-04T09:30:00Z&quot;), 139),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T10:00:00Z&quot;), Instant.parse(&quot;2025-05-04T10:30:00Z&quot;), 649),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T11:00:00Z&quot;), Instant.parse(&quot;2025-05-04T11:30:00Z&quot;), 426),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T12:00:00Z&quot;), Instant.parse(&quot;2025-05-04T12:30:00Z&quot;), 285),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T13:00:00Z&quot;), Instant.parse(&quot;2025-05-04T13:30:00Z&quot;), 981),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T14:00:00Z&quot;), Instant.parse(&quot;2025-05-04T14:30:00Z&quot;), 148),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T15:00:00Z&quot;), Instant.parse(&quot;2025-05-04T15:30:00Z&quot;), 845),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T16:00:00Z&quot;), Instant.parse(&quot;2025-05-04T16:30:00Z&quot;), 462),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T17:00:00Z&quot;), Instant.parse(&quot;2025-05-04T17:30:00Z&quot;), 139),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T18:00:00Z&quot;), Instant.parse(&quot;2025-05-04T18:30:00Z&quot;), 237),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T19:00:00Z&quot;), Instant.parse(&quot;2025-05-04T19:30:00Z&quot;), 739),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T20:00:00Z&quot;), Instant.parse(&quot;2025-05-04T20:30:00Z&quot;), 169),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T21:00:00Z&quot;), Instant.parse(&quot;2025-05-04T21:30:00Z&quot;), 878),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T22:00:00Z&quot;), Instant.parse(&quot;2025-05-04T22:30:00Z&quot;), 525),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T23:00:00Z&quot;), Instant.parse(&quot;2025-05-04T23:30:00Z&quot;), 826),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T00:00:00Z&quot;), Instant.parse(&quot;2025-05-05T00:30:00Z&quot;), 96),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T01:00:00Z&quot;), Instant.parse(&quot;2025-05-05T01:30:00Z&quot;), 80),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T02:00:00Z&quot;), Instant.parse(&quot;2025-05-05T02:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T03:00:00Z&quot;), Instant.parse(&quot;2025-05-05T03:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T04:00:00Z&quot;), Instant.parse(&quot;2025-05-05T04:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T05:00:00Z&quot;), Instant.parse(&quot;2025-05-05T05:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T06:00:00Z&quot;), Instant.parse(&quot;2025-05-05T06:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T07:00:00Z&quot;), Instant.parse(&quot;2025-05-05T07:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T08:00:00Z&quot;), Instant.parse(&quot;2025-05-05T08:30:00Z&quot;), 18),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T09:00:00Z&quot;), Instant.parse(&quot;2025-05-05T09:30:00Z&quot;), 289),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T10:00:00Z&quot;), Instant.parse(&quot;2025-05-05T10:30:00Z&quot;), 400),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T11:00:00Z&quot;), Instant.parse(&quot;2025-05-05T11:30:00Z&quot;), 576),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T12:00:00Z&quot;), Instant.parse(&quot;2025-05-05T12:30:00Z&quot;), 362),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T13:00:00Z&quot;), Instant.parse(&quot;2025-05-05T13:30:00Z&quot;), 738)&#10;//    )&#10;&#10;    /**&#10;     * Generates StepCount data with 0 steps from 02:00–08:00 local time.&#10;     * - intervalMinutes: typically 30&#10;     * - zoneId: used to decide sleep window in local time (default Asia/Seoul)&#10;     * - seed: pass a value for deterministic output; null = random&#10;     */&#10;    fun generateStepCounts(&#10;        startInclusive: Instant,&#10;        endExclusive: Instant,&#10;        intervalMinutes: Long = 30,&#10;        zoneId: ZoneId = ZoneId.of(&quot;Asia/Seoul&quot;),&#10;        seed: Long? = null&#10;    ): List&lt;StepCount&gt; {&#10;        require(!endExclusive.isBefore(startInclusive)) { &quot;endExclusive must be &gt;= startInclusive&quot; }&#10;        val rng = seed?.let { Random(it) } ?: Random(System.currentTimeMillis())&#10;&#10;        fun randomCountForLocalTime(zdt: ZonedDateTime): Int {&#10;            // Sleep window: 02:00–07:59 local time&#10;            if (zdt.hour in 2..7) return 0&#10;&#10;            val hour = zdt.hour&#10;            // Base ranges by time-of-day (tuned to look like your samples)&#10;            val (min, max) = when (hour) {&#10;                in 8..10 -&gt; 40 to 450    // ramp up morning&#10;                in 11..13 -&gt; 200 to 700  // mid-day move&#10;                in 14..17 -&gt; 300 to 850  // afternoon&#10;                in 18..21 -&gt; 350 to 950  // evening peak&#10;                else -&gt; 50 to 400        // late night &amp; very early morning outside sleep&#10;            }&#10;&#10;            // Smooth random with a slight burst chance&#10;            var v = rng.nextInt(min, max + 1)&#10;            if (rng.nextDouble() &lt; 0.12) v = (v * 1.3).roundToInt()  // occasional burst&#10;            return v.coerceIn(0, 1200)&#10;        }&#10;&#10;        val out = ArrayList&lt;StepCount&gt;()&#10;        var cursor = startInclusive&#10;        val step = Duration.ofMinutes(intervalMinutes)&#10;&#10;        while (cursor.isBefore(endExclusive)) {&#10;            val zdt = cursor.atZone(zoneId)&#10;            val count = randomCountForLocalTime(zdt).toLong()&#10;            val next = cursor.plus(step)&#10;            out += StepCount(cursor, next, count)&#10;            cursor = next&#10;        }&#10;        return out&#10;    }&#10;&#10;    fun getStepCountData(): List&lt;StepCount&gt; = generateStepCounts(&#10;        startInclusive = Instant.parse(&quot;2025-05-04T15:00:00Z&quot;),&#10;        endExclusive = Instant.parse(&quot;2025-05-11T14:00:00Z&quot;),&#10;        intervalMinutes = 30,&#10;        zoneId = ZoneId.of(&quot;Asia/Seoul&quot;),&#10;    )&#10;&#10;    fun getSingleSleepSessionData(): SleepSession = SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-04T22:29:00Z&quot;),&#10;            endTime   = Instant.parse(&quot;2025-05-05T06:09:00Z&quot;), &#10;            stages = listOf(&#10;                // ~10:29 PM - settling in&#10;                SleepStage(Instant.parse(&quot;2025-05-04T22:29:00Z&quot;), Instant.parse(&quot;2025-05-04T22:45:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-04T22:45:00Z&quot;), Instant.parse(&quot;2025-05-04T23:30:00Z&quot;), SleepStageType.DEEP),&#10;&#10;                // pre-midnight oscillations&#10;                SleepStage(Instant.parse(&quot;2025-05-04T23:30:00Z&quot;), Instant.parse(&quot;2025-05-05T00:10:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T00:10:00Z&quot;), Instant.parse(&quot;2025-05-05T00:20:00Z&quot;), SleepStageType.AWAKE),&#10;&#10;                // first solid REM patch&#10;                SleepStage(Instant.parse(&quot;2025-05-05T00:20:00Z&quot;), Instant.parse(&quot;2025-05-05T01:00:00Z&quot;), SleepStageType.REM),&#10;&#10;                // light → deep again&#10;                SleepStage(Instant.parse(&quot;2025-05-05T01:00:00Z&quot;), Instant.parse(&quot;2025-05-05T01:40:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T01:40:00Z&quot;), Instant.parse(&quot;2025-05-05T02:10:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T02:10:00Z&quot;), Instant.parse(&quot;2025-05-05T02:20:00Z&quot;), SleepStageType.AWAKE),&#10;&#10;                // mid-night light, brief REM&#10;                SleepStage(Instant.parse(&quot;2025-05-05T02:20:00Z&quot;), Instant.parse(&quot;2025-05-05T03:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T03:00:00Z&quot;), Instant.parse(&quot;2025-05-05T03:30:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T03:30:00Z&quot;), Instant.parse(&quot;2025-05-05T04:20:00Z&quot;), SleepStageType.LIGHT),&#10;&#10;                // another deep valley before dawn&#10;                SleepStage(Instant.parse(&quot;2025-05-05T04:20:00Z&quot;), Instant.parse(&quot;2025-05-05T04:50:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T04:50:00Z&quot;), Instant.parse(&quot;2025-05-05T05:00:00Z&quot;), SleepStageType.AWAKE),&#10;&#10;                // long REM run near morning&#10;                SleepStage(Instant.parse(&quot;2025-05-05T05:00:00Z&quot;), Instant.parse(&quot;2025-05-05T05:40:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T05:40:00Z&quot;), Instant.parse(&quot;2025-05-05T06:05:00Z&quot;), SleepStageType.LIGHT),&#10;&#10;                // final wake just before the alarm&#10;                SleepStage(Instant.parse(&quot;2025-05-05T06:05:00Z&quot;), Instant.parse(&quot;2025-05-05T06:09:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        )&#10;&#10;    fun getMultipleSleepSessionData(): List&lt;SleepSession&gt; = listOf(&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-04T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-04T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T00:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T02:00:00Z&quot;),&#10;                    SleepStageType.REM&#10;                ),&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T02:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T04:00:00Z&quot;),&#10;                    SleepStageType.REM&#10;                ),&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T04:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T06:00:00Z&quot;),&#10;                    SleepStageType.LIGHT&#10;                ),&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T06:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T08:00:00Z&quot;),&#10;                    SleepStageType.AWAKE&#10;                )&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-03T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-04T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-03T16:00:00Z&quot;), Instant.parse(&quot;2025-05-03T18:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T18:00:00Z&quot;), Instant.parse(&quot;2025-05-03T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T20:00:00Z&quot;), Instant.parse(&quot;2025-05-03T22:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T22:00:00Z&quot;), Instant.parse(&quot;2025-05-04T00:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-03T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-03T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), Instant.parse(&quot;2025-05-03T10:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T10:00:00Z&quot;), Instant.parse(&quot;2025-05-03T12:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T12:00:00Z&quot;), Instant.parse(&quot;2025-05-03T14:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T14:00:00Z&quot;), Instant.parse(&quot;2025-05-03T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-03T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-03T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-03T00:00:00Z&quot;), Instant.parse(&quot;2025-05-03T02:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T02:00:00Z&quot;), Instant.parse(&quot;2025-05-03T04:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T04:00:00Z&quot;), Instant.parse(&quot;2025-05-03T06:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T06:00:00Z&quot;), Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-02T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-03T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-02T16:00:00Z&quot;), Instant.parse(&quot;2025-05-02T18:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T18:00:00Z&quot;), Instant.parse(&quot;2025-05-02T20:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T20:00:00Z&quot;), Instant.parse(&quot;2025-05-02T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T22:00:00Z&quot;), Instant.parse(&quot;2025-05-03T00:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-02T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-02T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), Instant.parse(&quot;2025-05-02T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T10:00:00Z&quot;), Instant.parse(&quot;2025-05-02T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T12:00:00Z&quot;), Instant.parse(&quot;2025-05-02T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T14:00:00Z&quot;), Instant.parse(&quot;2025-05-02T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-02T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-02T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-02T00:00:00Z&quot;), Instant.parse(&quot;2025-05-02T02:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T02:00:00Z&quot;), Instant.parse(&quot;2025-05-02T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T04:00:00Z&quot;), Instant.parse(&quot;2025-05-02T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T06:00:00Z&quot;), Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-01T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-02T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-01T16:00:00Z&quot;), Instant.parse(&quot;2025-05-01T18:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T18:00:00Z&quot;), Instant.parse(&quot;2025-05-01T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T20:00:00Z&quot;), Instant.parse(&quot;2025-05-01T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T22:00:00Z&quot;), Instant.parse(&quot;2025-05-02T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-01T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-01T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), Instant.parse(&quot;2025-05-01T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T10:00:00Z&quot;), Instant.parse(&quot;2025-05-01T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T12:00:00Z&quot;), Instant.parse(&quot;2025-05-01T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T14:00:00Z&quot;), Instant.parse(&quot;2025-05-01T16:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-01T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-01T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-01T00:00:00Z&quot;), Instant.parse(&quot;2025-05-01T02:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T02:00:00Z&quot;), Instant.parse(&quot;2025-05-01T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T04:00:00Z&quot;), Instant.parse(&quot;2025-05-01T06:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T06:00:00Z&quot;), Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-30T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-01T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-30T16:00:00Z&quot;), Instant.parse(&quot;2025-04-30T18:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T18:00:00Z&quot;), Instant.parse(&quot;2025-04-30T20:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T20:00:00Z&quot;), Instant.parse(&quot;2025-04-30T22:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T22:00:00Z&quot;), Instant.parse(&quot;2025-05-01T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-30T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-30T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), Instant.parse(&quot;2025-04-30T10:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T10:00:00Z&quot;), Instant.parse(&quot;2025-04-30T12:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T12:00:00Z&quot;), Instant.parse(&quot;2025-04-30T14:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T14:00:00Z&quot;), Instant.parse(&quot;2025-04-30T16:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-30T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-30T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-30T00:00:00Z&quot;), Instant.parse(&quot;2025-04-30T02:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T02:00:00Z&quot;), Instant.parse(&quot;2025-04-30T04:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T04:00:00Z&quot;), Instant.parse(&quot;2025-04-30T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T06:00:00Z&quot;), Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-29T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-30T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-29T16:00:00Z&quot;), Instant.parse(&quot;2025-04-29T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T18:00:00Z&quot;), Instant.parse(&quot;2025-04-29T20:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T20:00:00Z&quot;), Instant.parse(&quot;2025-04-29T22:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T22:00:00Z&quot;), Instant.parse(&quot;2025-04-30T00:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-29T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-29T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), Instant.parse(&quot;2025-04-29T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T10:00:00Z&quot;), Instant.parse(&quot;2025-04-29T12:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T12:00:00Z&quot;), Instant.parse(&quot;2025-04-29T14:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T14:00:00Z&quot;), Instant.parse(&quot;2025-04-29T16:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-29T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-29T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-29T00:00:00Z&quot;), Instant.parse(&quot;2025-04-29T02:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T02:00:00Z&quot;), Instant.parse(&quot;2025-04-29T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T04:00:00Z&quot;), Instant.parse(&quot;2025-04-29T06:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T06:00:00Z&quot;), Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-28T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-29T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-28T16:00:00Z&quot;), Instant.parse(&quot;2025-04-28T18:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T18:00:00Z&quot;), Instant.parse(&quot;2025-04-28T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T20:00:00Z&quot;), Instant.parse(&quot;2025-04-28T22:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T22:00:00Z&quot;), Instant.parse(&quot;2025-04-29T00:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-28T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-28T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), Instant.parse(&quot;2025-04-28T10:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T10:00:00Z&quot;), Instant.parse(&quot;2025-04-28T12:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T12:00:00Z&quot;), Instant.parse(&quot;2025-04-28T14:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T14:00:00Z&quot;), Instant.parse(&quot;2025-04-28T16:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-28T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-28T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-28T00:00:00Z&quot;), Instant.parse(&quot;2025-04-28T02:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T02:00:00Z&quot;), Instant.parse(&quot;2025-04-28T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T04:00:00Z&quot;), Instant.parse(&quot;2025-04-28T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T06:00:00Z&quot;), Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-27T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-28T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-27T16:00:00Z&quot;), Instant.parse(&quot;2025-04-27T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T18:00:00Z&quot;), Instant.parse(&quot;2025-04-27T20:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T20:00:00Z&quot;), Instant.parse(&quot;2025-04-27T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T22:00:00Z&quot;), Instant.parse(&quot;2025-04-28T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-27T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-27T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), Instant.parse(&quot;2025-04-27T10:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T10:00:00Z&quot;), Instant.parse(&quot;2025-04-27T12:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T12:00:00Z&quot;), Instant.parse(&quot;2025-04-27T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T14:00:00Z&quot;), Instant.parse(&quot;2025-04-27T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-27T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-27T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-27T00:00:00Z&quot;), Instant.parse(&quot;2025-04-27T02:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T02:00:00Z&quot;), Instant.parse(&quot;2025-04-27T04:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T04:00:00Z&quot;), Instant.parse(&quot;2025-04-27T06:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T06:00:00Z&quot;), Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-26T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-27T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-26T16:00:00Z&quot;), Instant.parse(&quot;2025-04-26T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T18:00:00Z&quot;), Instant.parse(&quot;2025-04-26T20:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T20:00:00Z&quot;), Instant.parse(&quot;2025-04-26T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T22:00:00Z&quot;), Instant.parse(&quot;2025-04-27T00:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-26T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-26T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), Instant.parse(&quot;2025-04-26T10:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T10:00:00Z&quot;), Instant.parse(&quot;2025-04-26T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T12:00:00Z&quot;), Instant.parse(&quot;2025-04-26T14:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T14:00:00Z&quot;), Instant.parse(&quot;2025-04-26T16:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-26T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-26T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-26T00:00:00Z&quot;), Instant.parse(&quot;2025-04-26T02:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T02:00:00Z&quot;), Instant.parse(&quot;2025-04-26T04:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T04:00:00Z&quot;), Instant.parse(&quot;2025-04-26T06:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T06:00:00Z&quot;), Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-25T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-26T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-25T16:00:00Z&quot;), Instant.parse(&quot;2025-04-25T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T18:00:00Z&quot;), Instant.parse(&quot;2025-04-25T20:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T20:00:00Z&quot;), Instant.parse(&quot;2025-04-25T22:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T22:00:00Z&quot;), Instant.parse(&quot;2025-04-26T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-25T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-25T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), Instant.parse(&quot;2025-04-25T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T10:00:00Z&quot;), Instant.parse(&quot;2025-04-25T12:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T12:00:00Z&quot;), Instant.parse(&quot;2025-04-25T14:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T14:00:00Z&quot;), Instant.parse(&quot;2025-04-25T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-25T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-25T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-25T00:00:00Z&quot;), Instant.parse(&quot;2025-04-25T02:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T02:00:00Z&quot;), Instant.parse(&quot;2025-04-25T04:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T04:00:00Z&quot;), Instant.parse(&quot;2025-04-25T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T06:00:00Z&quot;), Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-24T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-25T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-24T16:00:00Z&quot;), Instant.parse(&quot;2025-04-24T18:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T18:00:00Z&quot;), Instant.parse(&quot;2025-04-24T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T20:00:00Z&quot;), Instant.parse(&quot;2025-04-24T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T22:00:00Z&quot;), Instant.parse(&quot;2025-04-25T00:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-24T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-24T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), Instant.parse(&quot;2025-04-24T10:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T10:00:00Z&quot;), Instant.parse(&quot;2025-04-24T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T12:00:00Z&quot;), Instant.parse(&quot;2025-04-24T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T14:00:00Z&quot;), Instant.parse(&quot;2025-04-24T16:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        )&#10;    )&#10;&#10;    /**&#10;     * Sample weight data spanning 30 days&#10;     */&#10;    fun getWeightData(): List&lt;Weight&gt; = listOf(&#10;        Weight(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), Mass.kilograms(74.7)),&#10;        Weight(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), Mass.kilograms(68.6)),&#10;        Weight(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), Mass.kilograms(71.6)),&#10;        Weight(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), Mass.kilograms(74.2)),&#10;        Weight(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), Mass.kilograms(60.6)),&#10;        Weight(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), Mass.kilograms(73.8)),&#10;        Weight(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), Mass.kilograms(65.8)),&#10;        Weight(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), Mass.kilograms(73.2)),&#10;        Weight(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), Mass.kilograms(73.8)),&#10;        Weight(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), Mass.kilograms(67.5)),&#10;        Weight(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), Mass.kilograms(70.4)),&#10;        Weight(Instant.parse(&quot;2025-04-23T08:00:00Z&quot;), Mass.kilograms(61.4)),&#10;        Weight(Instant.parse(&quot;2025-04-22T08:00:00Z&quot;), Mass.kilograms(74.8)),&#10;        Weight(Instant.parse(&quot;2025-04-21T08:00:00Z&quot;), Mass.kilograms(66.1)),&#10;        Weight(Instant.parse(&quot;2025-04-20T08:00:00Z&quot;), Mass.kilograms(63.9)),&#10;        Weight(Instant.parse(&quot;2025-04-19T08:00:00Z&quot;), Mass.kilograms(67.9)),&#10;        Weight(Instant.parse(&quot;2025-04-18T08:00:00Z&quot;), Mass.kilograms(67.3)),&#10;        Weight(Instant.parse(&quot;2025-04-17T08:00:00Z&quot;), Mass.kilograms(66.8)),&#10;        Weight(Instant.parse(&quot;2025-04-16T08:00:00Z&quot;), Mass.kilograms(67.9)),&#10;        Weight(Instant.parse(&quot;2025-04-15T08:00:00Z&quot;), Mass.kilograms(66.4)),&#10;        Weight(Instant.parse(&quot;2025-04-14T08:00:00Z&quot;), Mass.kilograms(74.6)),&#10;        Weight(Instant.parse(&quot;2025-04-13T08:00:00Z&quot;), Mass.kilograms(66.1)),&#10;        Weight(Instant.parse(&quot;2025-04-12T08:00:00Z&quot;), Mass.kilograms(71.5)),&#10;        Weight(Instant.parse(&quot;2025-04-11T08:00:00Z&quot;), Mass.kilograms(72.9)),&#10;        Weight(Instant.parse(&quot;2025-04-10T08:00:00Z&quot;), Mass.kilograms(70.8)),&#10;        Weight(Instant.parse(&quot;2025-04-09T08:00:00Z&quot;), Mass.kilograms(69.9)),&#10;        Weight(Instant.parse(&quot;2025-04-08T08:00:00Z&quot;), Mass.kilograms(60.9)),&#10;        Weight(Instant.parse(&quot;2025-04-07T08:00:00Z&quot;), Mass.kilograms(66.9)),&#10;        Weight(Instant.parse(&quot;2025-04-06T08:00:00Z&quot;), Mass.kilograms(69.3)),&#10;        Weight(Instant.parse(&quot;2025-04-05T08:00:00Z&quot;), Mass.kilograms(61.1))&#10;    )&#10;&#10;    fun getBodyFatData(): List&lt;BodyFat&gt; = listOf(&#10;        BodyFat(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), 22.1),&#10;        BodyFat(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), 24.2),&#10;        BodyFat(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), 20.7),&#10;        BodyFat(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), 18.3),&#10;        BodyFat(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), 20.9),&#10;        BodyFat(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), 15.3),&#10;        BodyFat(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), 18.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), 19.4),&#10;        BodyFat(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), 18.3),&#10;        BodyFat(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), 19.8),&#10;        BodyFat(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), 21.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-23T08:00:00Z&quot;), 22.1),&#10;        BodyFat(Instant.parse(&quot;2025-04-22T08:00:00Z&quot;), 22.4),&#10;        BodyFat(Instant.parse(&quot;2025-04-21T08:00:00Z&quot;), 21.6),&#10;        BodyFat(Instant.parse(&quot;2025-04-20T08:00:00Z&quot;), 19.2),&#10;        BodyFat(Instant.parse(&quot;2025-04-19T08:00:00Z&quot;), 20.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-18T08:00:00Z&quot;), 17.9),&#10;        BodyFat(Instant.parse(&quot;2025-04-17T08:00:00Z&quot;), 16.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-16T08:00:00Z&quot;), 15.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-15T08:00:00Z&quot;), 14.4),&#10;        BodyFat(Instant.parse(&quot;2025-04-14T08:00:00Z&quot;), 18.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-13T08:00:00Z&quot;), 16.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-12T08:00:00Z&quot;), 17.5),&#10;        BodyFat(Instant.parse(&quot;2025-04-11T08:00:00Z&quot;), 12.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-10T08:00:00Z&quot;), 14.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-09T08:00:00Z&quot;), 11.8),&#10;        BodyFat(Instant.parse(&quot;2025-04-08T08:00:00Z&quot;), 13.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-07T08:00:00Z&quot;), 13.1),&#10;        BodyFat(Instant.parse(&quot;2025-04-06T08:00:00Z&quot;), 13.2),&#10;        BodyFat(Instant.parse(&quot;2025-04-05T08:00:00Z&quot;), 12.9)&#10;    )&#10;&#10;    fun getBloodPressureData(): List&lt;BloodPressure&gt; = listOf(&#10;        BloodPressure(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), 119.5, 73.3),&#10;        BloodPressure(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), 123.4, 82.6),&#10;        BloodPressure(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), 115.2, 84.9),&#10;        BloodPressure(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), 128.2, 81.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), 129.3, 71.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), 118.5, 79.6),&#10;        BloodPressure(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), 120.4, 71.5),&#10;        BloodPressure(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), 113.1, 80.9),&#10;        BloodPressure(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), 112.8, 82.1),&#10;        BloodPressure(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), 114.9, 79.3),&#10;        BloodPressure(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), 124.3, 70.1),&#10;        BloodPressure(Instant.parse(&quot;2025-04-23T08:00:00Z&quot;), 123.1, 82.6),&#10;        BloodPressure(Instant.parse(&quot;2025-04-22T08:00:00Z&quot;), 123.4, 82.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-21T08:00:00Z&quot;), 122.0, 80.9),&#10;        BloodPressure(Instant.parse(&quot;2025-04-20T08:00:00Z&quot;), 118.8, 80.4),&#10;        BloodPressure(Instant.parse(&quot;2025-04-19T08:00:00Z&quot;), 123.2, 76.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-18T08:00:00Z&quot;), 113.0, 84.4),&#10;        BloodPressure(Instant.parse(&quot;2025-04-17T08:00:00Z&quot;), 115.5, 82.6),&#10;        BloodPressure(Instant.parse(&quot;2025-04-16T08:00:00Z&quot;), 123.9, 83.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-15T08:00:00Z&quot;), 111.4, 79.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-14T08:00:00Z&quot;), 119.5, 84.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-13T08:00:00Z&quot;), 114.1, 71.0),&#10;        BloodPressure(Instant.parse(&quot;2025-04-12T08:00:00Z&quot;), 116.1, 81.9),&#10;        BloodPressure(Instant.parse(&quot;2025-04-11T08:00:00Z&quot;), 121.9, 76.5),&#10;        BloodPressure(Instant.parse(&quot;2025-04-10T08:00:00Z&quot;), 123.9, 73.0),&#10;        BloodPressure(Instant.parse(&quot;2025-04-09T08:00:00Z&quot;), 119.1, 83.1),&#10;        BloodPressure(Instant.parse(&quot;2025-04-08T08:00:00Z&quot;), 129.2, 72.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-07T08:00:00Z&quot;), 123.4, 78.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-06T08:00:00Z&quot;), 126.2, 76.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-05T08:00:00Z&quot;), 111.5, 84.7)&#10;    )&#10;&#10;    /**&#10;     * Sample heart rate range data for range bar charts&#10;     * Returns List&lt;ChartPoint&gt; where multiple points with same x-value represent min and max values&#10;     */&#10;    fun getHeartRateRangeData(): List&lt;ChartPoint&gt; = listOf(&#10;        // Day 2 (x = 0)&#10;        ChartPoint(x = 0f, y = 54f, label = &quot;2일&quot;), // min&#10;        ChartPoint(x = 0f, y = 160f, label = &quot;2일&quot;), // max&#10;&#10;        // Day 3 (x = 1)&#10;        ChartPoint(x = 1f, y = 65f, label = &quot;3일&quot;), // min&#10;        ChartPoint(x = 1f, y = 145f, label = &quot;3일&quot;), // max&#10;&#10;        // Day 4 (x = 2)&#10;        ChartPoint(x = 2f, y = 58f, label = &quot;4일&quot;), // min&#10;        ChartPoint(x = 2f, y = 125f, label = &quot;4일&quot;), // max&#10;&#10;        // Day 6 (x = 3)&#10;        ChartPoint(x = 3f, y = 75f, label = &quot;6일&quot;), // min&#10;        ChartPoint(x = 3f, y = 110f, label = &quot;6일&quot;), // max&#10;&#10;        // Day 7 (x = 4)&#10;        ChartPoint(x = 4f, y = 68f, label = &quot;7일&quot;), // min&#10;        ChartPoint(x = 4f, y = 162f, label = &quot;7일&quot;), // max&#10;&#10;        // Day 8 (x = 5)&#10;        ChartPoint(x = 5f, y = 72f, label = &quot;8일&quot;), // min&#10;        ChartPoint(x = 5f, y = 168f, label = &quot;8일&quot;), // max&#10;&#10;        // Day 9 (x = 6)&#10;        ChartPoint(x = 6f, y = 65f, label = &quot;9일&quot;), // min&#10;        ChartPoint(x = 6f, y = 138f, label = &quot;9일&quot;), // max&#10;&#10;        // Day 10 (x = 7)&#10;        ChartPoint(x = 7f, y = 85f, label = &quot;10일&quot;), // min&#10;        ChartPoint(x = 7f, y = 105f, label = &quot;10일&quot;) // max&#10;    )&#10;&#10;    /**&#10;     * Sample nutrition data for stacked bar charts (protein, fat, carbs)&#10;     * Returns List&lt;ChartPoint&gt; where multiple points with same x-value represent different segments&#10;     */&#10;    fun getNutritionStackedData(): List&lt;ChartPoint&gt; = listOf(&#10;        // Monday (x = 0)&#10;        ChartPoint(x = 0f, y = 80f, label = &quot;월&quot;),&#10;        ChartPoint(x = 0f, y = 45f, label = &quot;월&quot;),&#10;        ChartPoint(x = 0f, y = 120f, label = &quot;월&quot;),&#10;&#10;        // Tuesday (x = 1)&#10;        ChartPoint(x = 1f, y = 75f, label = &quot;화&quot;),&#10;        ChartPoint(x = 1f, y = 38f, label = &quot;화&quot;),&#10;        ChartPoint(x = 1f, y = 110f, label = &quot;화&quot;),&#10;&#10;        // Wednesday (x = 2)&#10;        ChartPoint(x = 2f, y = 90f, label = &quot;수&quot;),&#10;        ChartPoint(x = 2f, y = 52f, label = &quot;수&quot;),&#10;        ChartPoint(x = 2f, y = 140f, label = &quot;수&quot;),&#10;&#10;        // Thursday (x = 3)&#10;        ChartPoint(x = 3f, y = 85f, label = &quot;목&quot;),&#10;        ChartPoint(x = 3f, y = 41f, label = &quot;목&quot;),&#10;        ChartPoint(x = 3f, y = 135f, label = &quot;목&quot;),&#10;&#10;        // Friday (x = 4)&#10;        ChartPoint(x = 4f, y = 95f, label = &quot;금&quot;),&#10;        ChartPoint(x = 4f, y = 58f, label = &quot;금&quot;),&#10;        ChartPoint(x = 4f, y = 150f, label = &quot;금&quot;),&#10;&#10;        // Saturday (x = 5)&#10;        ChartPoint(x = 5f, y = 70f, label = &quot;토&quot;),&#10;        ChartPoint(x = 5f, y = 35f, label = &quot;토&quot;),&#10;        ChartPoint(x = 5f, y = 100f, label = &quot;토&quot;),&#10;&#10;        // Sunday (x = 6)&#10;        ChartPoint(x = 6f, y = 88f, label = &quot;일&quot;),&#10;        ChartPoint(x = 6f, y = 48f, label = &quot;일&quot;),&#10;        ChartPoint(x = 6f, y = 125f, label = &quot;일&quot;)&#10;    )&#10;&#10;    /**&#10;     * Sample progress data for Apple Watch-style activity rings&#10;     */&#10;    fun getActivityProgressData(): List&lt;ProgressChartPoint&gt; = listOf(&#10;        ProgressChartPoint(x = 0f, current = 1200f, max = 2000f, label = &quot;Move&quot;, unit = &quot;KJ&quot;),&#10;        ProgressChartPoint(x = 1f, current = 20f, max = 60f, label = &quot;Exercise&quot;, unit = &quot;min&quot;),&#10;        ProgressChartPoint(x = 2f, current = 7f, max = 10f, label = &quot;Stand&quot;, unit = &quot;h&quot;)&#10;    )&#10;&#10;    /**&#10;     * Sample calendar entries for calendar charts&#10;     */&#10;    fun getCalendarEntries(yearMonth: YearMonth = YearMonth.now()): List&lt;CalendarEntry&gt; {&#10;        val startDate = LocalDate.of(yearMonth.year, yearMonth.monthValue, 1)&#10;        val endDate = LocalDate.of(yearMonth.year, yearMonth.monthValue, yearMonth.lengthOfMonth())&#10;        val random = java.util.Random(0)&#10;        &#10;        return generateSequence(startDate) { date -&gt;&#10;            if (date.isBefore(endDate)) date.plusDays(1) else null&#10;        }.map { date -&gt;&#10;            val value = random.nextFloat() * 100&#10;            CalendarEntry(date = date, value = value)&#10;        }.toList()&#10;    }&#10;&#10;    /**&#10;     * Convert basic sample data to ChartPoint format&#10;     */&#10;    fun getBasicChartPoints(): List&lt;ChartPoint&gt; = sampleData.mapIndexed { index, value -&gt;&#10;        ChartPoint(x = index.toFloat(), y = value, label = weekDays.getOrElse(index) { &quot;&quot; })&#10;    }&#10;&#10;    /**&#10;     * Convert extended sample data to ChartPoint format (for pagination demos)&#10;     */&#10;    fun getExtendedChartPoints(): List&lt;ChartPoint&gt; = sampleData4.mapIndexed { index, value -&gt;&#10;        ChartPoint(x = index.toFloat(), y = value, label = weekDays[index % weekDays.size])&#10;    }&#10;&#10;    /**&#10;     * Generate dense chart points for tick reduction demos&#10;     */&#10;    fun getDenseChartPoints(count: Int = 50): List&lt;ChartPoint&gt; {&#10;        val labels = (1..count).map { &quot;Day $it&quot; }&#10;        val values = (1..count).map { (20..80).random().toFloat() }&#10;        return labels.mapIndexed { index, label -&gt;&#10;            ChartPoint(x = index.toFloat(), y = values[index], label = label)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get blood pressure data as separate ChartPoint lists for systolic and diastolic&#10;     * Uses the transform convenience function for proper time-based processing&#10;     */&#10;    fun getBloodPressureChartPointsMap(): Map&lt;String, List&lt;ChartPoint&gt;&gt; {&#10;        return getBloodPressureData().transform(&#10;            timeUnit = TimeUnitGroup.DAY,&#10;            aggregationType = AggregationType.DAILY_AVERAGE&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.data.provider&#10;&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ProgressChartPoint&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;import com.hdil.saluschart.core.transform.transform&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.util.AggregationType&#10;import com.hdil.saluschart.data.model.model.BloodPressure&#10;import com.hdil.saluschart.data.model.model.BodyFat&#10;import com.hdil.saluschart.data.model.model.Mass&#10;import com.hdil.saluschart.data.model.model.SleepSession&#10;import com.hdil.saluschart.data.model.model.SleepStage&#10;import com.hdil.saluschart.data.model.model.StepCount&#10;import com.hdil.saluschart.data.model.model.Weight&#10;import com.hdil.saluschart.ui.compose.charts.CalendarEntry&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.YearMonth&#10;import java.time.*&#10;import kotlin.random.Random&#10;import kotlin.math.roundToInt&#10;&#10;&#10;/**&#10; * Provides sample data for demonstration and testing purposes.&#10; * All sample data is organized here for better maintainability.&#10; */&#10;object SampleDataProvider {&#10;    &#10;    // Basic sample data arrays&#10;    val sampleData = listOf(10f, 25f, 40f, 20f, 35f, 55f, 45f)&#10;    val sampleData2 = listOf(5f, 15f, 60f, 45f, 35f, 25f, 10f)&#10;    val sampleData3 = listOf(8f, 22f, 10f, 40f, 18f, 32f, 12f)&#10;    val sampleData4 = listOf(10f, 25f, 40f, 20f, 35f, 55f, 45f, 5f, 15f, 60f, 45f, 35f, 25f, 10f, 8f, 22f, 10f, 40f, 18f, 32f, 12f)&#10;    &#10;    // Week days labels&#10;    val weekDays = listOf(&quot;월&quot;, &quot;화&quot;, &quot;수&quot;, &quot;목&quot;, &quot;금&quot;, &quot;토&quot;, &quot;일&quot;)&#10;    &#10;    // Nutrition segment labels for stacked charts&#10;    val segmentLabels = listOf(&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;)&#10;&#10;    /**&#10;     * Sample step count health data spanning two days with 30-minute intervals&#10;     */&#10;//    fun getStepCountData(): List&lt;StepCount&gt; = listOf(&#10;//        StepCount(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), Instant.parse(&quot;2025-05-04T08:30:00Z&quot;), 43),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T09:00:00Z&quot;), Instant.parse(&quot;2025-05-04T09:30:00Z&quot;), 139),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T10:00:00Z&quot;), Instant.parse(&quot;2025-05-04T10:30:00Z&quot;), 649),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T11:00:00Z&quot;), Instant.parse(&quot;2025-05-04T11:30:00Z&quot;), 426),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T12:00:00Z&quot;), Instant.parse(&quot;2025-05-04T12:30:00Z&quot;), 285),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T13:00:00Z&quot;), Instant.parse(&quot;2025-05-04T13:30:00Z&quot;), 981),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T14:00:00Z&quot;), Instant.parse(&quot;2025-05-04T14:30:00Z&quot;), 148),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T15:00:00Z&quot;), Instant.parse(&quot;2025-05-04T15:30:00Z&quot;), 845),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T16:00:00Z&quot;), Instant.parse(&quot;2025-05-04T16:30:00Z&quot;), 462),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T17:00:00Z&quot;), Instant.parse(&quot;2025-05-04T17:30:00Z&quot;), 139),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T18:00:00Z&quot;), Instant.parse(&quot;2025-05-04T18:30:00Z&quot;), 237),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T19:00:00Z&quot;), Instant.parse(&quot;2025-05-04T19:30:00Z&quot;), 739),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T20:00:00Z&quot;), Instant.parse(&quot;2025-05-04T20:30:00Z&quot;), 169),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T21:00:00Z&quot;), Instant.parse(&quot;2025-05-04T21:30:00Z&quot;), 878),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T22:00:00Z&quot;), Instant.parse(&quot;2025-05-04T22:30:00Z&quot;), 525),&#10;//        StepCount(Instant.parse(&quot;2025-05-04T23:00:00Z&quot;), Instant.parse(&quot;2025-05-04T23:30:00Z&quot;), 826),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T00:00:00Z&quot;), Instant.parse(&quot;2025-05-05T00:30:00Z&quot;), 96),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T01:00:00Z&quot;), Instant.parse(&quot;2025-05-05T01:30:00Z&quot;), 80),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T02:00:00Z&quot;), Instant.parse(&quot;2025-05-05T02:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T03:00:00Z&quot;), Instant.parse(&quot;2025-05-05T03:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T04:00:00Z&quot;), Instant.parse(&quot;2025-05-05T04:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T05:00:00Z&quot;), Instant.parse(&quot;2025-05-05T05:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T06:00:00Z&quot;), Instant.parse(&quot;2025-05-05T06:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T07:00:00Z&quot;), Instant.parse(&quot;2025-05-05T07:30:00Z&quot;), 0),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T08:00:00Z&quot;), Instant.parse(&quot;2025-05-05T08:30:00Z&quot;), 18),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T09:00:00Z&quot;), Instant.parse(&quot;2025-05-05T09:30:00Z&quot;), 289),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T10:00:00Z&quot;), Instant.parse(&quot;2025-05-05T10:30:00Z&quot;), 400),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T11:00:00Z&quot;), Instant.parse(&quot;2025-05-05T11:30:00Z&quot;), 576),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T12:00:00Z&quot;), Instant.parse(&quot;2025-05-05T12:30:00Z&quot;), 362),&#10;//        StepCount(Instant.parse(&quot;2025-05-05T13:00:00Z&quot;), Instant.parse(&quot;2025-05-05T13:30:00Z&quot;), 738)&#10;//    )&#10;&#10;    /**&#10;     * Generates StepCount data with 0 steps from 02:00–08:00 local time.&#10;     * - intervalMinutes: typically 30&#10;     * - zoneId: used to decide sleep window in local time (default Asia/Seoul)&#10;     * - seed: pass a value for deterministic output; null = random&#10;     */&#10;    fun generateStepCounts(&#10;        startInclusive: Instant,&#10;        endExclusive: Instant,&#10;        intervalMinutes: Long = 30,&#10;        zoneId: ZoneId = ZoneId.of(&quot;Asia/Seoul&quot;),&#10;        seed: Long? = null&#10;    ): List&lt;StepCount&gt; {&#10;        require(!endExclusive.isBefore(startInclusive)) { &quot;endExclusive must be &gt;= startInclusive&quot; }&#10;        val rng = seed?.let { Random(it) } ?: Random(System.currentTimeMillis())&#10;&#10;        fun randomCountForLocalTime(zdt: ZonedDateTime): Int {&#10;            // Sleep window: 02:00–07:59 local time&#10;            if (zdt.hour in 2..7) return 0&#10;&#10;            val hour = zdt.hour&#10;            // Base ranges by time-of-day (tuned to look like your samples)&#10;            val (min, max) = when (hour) {&#10;                in 8..10 -&gt; 40 to 450    // ramp up morning&#10;                in 11..13 -&gt; 200 to 700  // mid-day move&#10;                in 14..17 -&gt; 300 to 850  // afternoon&#10;                in 18..21 -&gt; 350 to 950  // evening peak&#10;                else -&gt; 50 to 400        // late night &amp; very early morning outside sleep&#10;            }&#10;&#10;            // Smooth random with a slight burst chance&#10;            var v = rng.nextInt(min, max + 1)&#10;            if (rng.nextDouble() &lt; 0.12) v = (v * 1.3).roundToInt()  // occasional burst&#10;            return v.coerceIn(0, 1200)&#10;        }&#10;&#10;        val out = ArrayList&lt;StepCount&gt;()&#10;        var cursor = startInclusive&#10;        val step = Duration.ofMinutes(intervalMinutes)&#10;&#10;        while (cursor.isBefore(endExclusive)) {&#10;            val zdt = cursor.atZone(zoneId)&#10;            val count = randomCountForLocalTime(zdt).toLong()&#10;            val next = cursor.plus(step)&#10;            out += StepCount(cursor, next, count)&#10;            cursor = next&#10;        }&#10;        return out&#10;    }&#10;&#10;    fun getStepCountData(): List&lt;StepCount&gt; = generateStepCounts(&#10;        startInclusive = Instant.parse(&quot;2025-05-04T15:00:00Z&quot;),&#10;        endExclusive = Instant.parse(&quot;2025-05-11T14:00:00Z&quot;),&#10;        intervalMinutes = 30,&#10;        zoneId = ZoneId.of(&quot;Asia/Seoul&quot;),&#10;    )&#10;&#10;    fun getSingleSleepSessionData(): SleepSession = SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-04T22:29:00Z&quot;),&#10;            endTime   = Instant.parse(&quot;2025-05-05T06:09:00Z&quot;), &#10;            stages = listOf(&#10;                // ~10:29 PM - settling in&#10;                SleepStage(Instant.parse(&quot;2025-05-04T22:29:00Z&quot;), Instant.parse(&quot;2025-05-04T22:45:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-04T22:45:00Z&quot;), Instant.parse(&quot;2025-05-04T23:30:00Z&quot;), SleepStageType.DEEP),&#10;&#10;                // pre-midnight oscillations&#10;                SleepStage(Instant.parse(&quot;2025-05-04T23:30:00Z&quot;), Instant.parse(&quot;2025-05-05T00:10:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T00:10:00Z&quot;), Instant.parse(&quot;2025-05-05T00:20:00Z&quot;), SleepStageType.AWAKE),&#10;&#10;                // first solid REM patch&#10;                SleepStage(Instant.parse(&quot;2025-05-05T00:20:00Z&quot;), Instant.parse(&quot;2025-05-05T01:00:00Z&quot;), SleepStageType.REM),&#10;&#10;                // light → deep again&#10;                SleepStage(Instant.parse(&quot;2025-05-05T01:00:00Z&quot;), Instant.parse(&quot;2025-05-05T01:40:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T01:40:00Z&quot;), Instant.parse(&quot;2025-05-05T02:10:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T02:10:00Z&quot;), Instant.parse(&quot;2025-05-05T02:20:00Z&quot;), SleepStageType.AWAKE),&#10;&#10;                // mid-night light, brief REM&#10;                SleepStage(Instant.parse(&quot;2025-05-05T02:20:00Z&quot;), Instant.parse(&quot;2025-05-05T03:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T03:00:00Z&quot;), Instant.parse(&quot;2025-05-05T03:30:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T03:30:00Z&quot;), Instant.parse(&quot;2025-05-05T04:20:00Z&quot;), SleepStageType.LIGHT),&#10;&#10;                // another deep valley before dawn&#10;                SleepStage(Instant.parse(&quot;2025-05-05T04:20:00Z&quot;), Instant.parse(&quot;2025-05-05T04:50:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T04:50:00Z&quot;), Instant.parse(&quot;2025-05-05T05:00:00Z&quot;), SleepStageType.AWAKE),&#10;&#10;                // long REM run near morning&#10;                SleepStage(Instant.parse(&quot;2025-05-05T05:00:00Z&quot;), Instant.parse(&quot;2025-05-05T05:40:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-05T05:40:00Z&quot;), Instant.parse(&quot;2025-05-05T06:05:00Z&quot;), SleepStageType.LIGHT),&#10;&#10;                // final wake just before the alarm&#10;                SleepStage(Instant.parse(&quot;2025-05-05T06:05:00Z&quot;), Instant.parse(&quot;2025-05-05T06:09:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        )&#10;&#10;    fun getMultipleSleepSessionData(): List&lt;SleepSession&gt; = listOf(&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-04T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-04T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T00:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T02:00:00Z&quot;),&#10;                    SleepStageType.REM&#10;                ),&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T02:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T04:00:00Z&quot;),&#10;                    SleepStageType.REM&#10;                ),&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T04:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T06:00:00Z&quot;),&#10;                    SleepStageType.LIGHT&#10;                ),&#10;                SleepStage(&#10;                    Instant.parse(&quot;2025-05-04T06:00:00Z&quot;),&#10;                    Instant.parse(&quot;2025-05-04T08:00:00Z&quot;),&#10;                    SleepStageType.AWAKE&#10;                )&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-03T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-04T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-03T16:00:00Z&quot;), Instant.parse(&quot;2025-05-03T18:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T18:00:00Z&quot;), Instant.parse(&quot;2025-05-03T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T20:00:00Z&quot;), Instant.parse(&quot;2025-05-03T22:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T22:00:00Z&quot;), Instant.parse(&quot;2025-05-04T00:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-03T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-03T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), Instant.parse(&quot;2025-05-03T10:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T10:00:00Z&quot;), Instant.parse(&quot;2025-05-03T12:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T12:00:00Z&quot;), Instant.parse(&quot;2025-05-03T14:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T14:00:00Z&quot;), Instant.parse(&quot;2025-05-03T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-03T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-03T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-03T00:00:00Z&quot;), Instant.parse(&quot;2025-05-03T02:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T02:00:00Z&quot;), Instant.parse(&quot;2025-05-03T04:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T04:00:00Z&quot;), Instant.parse(&quot;2025-05-03T06:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-03T06:00:00Z&quot;), Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-02T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-03T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-02T16:00:00Z&quot;), Instant.parse(&quot;2025-05-02T18:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T18:00:00Z&quot;), Instant.parse(&quot;2025-05-02T20:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T20:00:00Z&quot;), Instant.parse(&quot;2025-05-02T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T22:00:00Z&quot;), Instant.parse(&quot;2025-05-03T00:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-02T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-02T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), Instant.parse(&quot;2025-05-02T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T10:00:00Z&quot;), Instant.parse(&quot;2025-05-02T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T12:00:00Z&quot;), Instant.parse(&quot;2025-05-02T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T14:00:00Z&quot;), Instant.parse(&quot;2025-05-02T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-02T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-02T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-02T00:00:00Z&quot;), Instant.parse(&quot;2025-05-02T02:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T02:00:00Z&quot;), Instant.parse(&quot;2025-05-02T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T04:00:00Z&quot;), Instant.parse(&quot;2025-05-02T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-02T06:00:00Z&quot;), Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-01T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-02T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-01T16:00:00Z&quot;), Instant.parse(&quot;2025-05-01T18:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T18:00:00Z&quot;), Instant.parse(&quot;2025-05-01T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T20:00:00Z&quot;), Instant.parse(&quot;2025-05-01T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T22:00:00Z&quot;), Instant.parse(&quot;2025-05-02T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-01T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-01T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), Instant.parse(&quot;2025-05-01T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T10:00:00Z&quot;), Instant.parse(&quot;2025-05-01T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T12:00:00Z&quot;), Instant.parse(&quot;2025-05-01T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T14:00:00Z&quot;), Instant.parse(&quot;2025-05-01T16:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-05-01T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-01T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-05-01T00:00:00Z&quot;), Instant.parse(&quot;2025-05-01T02:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T02:00:00Z&quot;), Instant.parse(&quot;2025-05-01T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T04:00:00Z&quot;), Instant.parse(&quot;2025-05-01T06:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-05-01T06:00:00Z&quot;), Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-30T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-05-01T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-30T16:00:00Z&quot;), Instant.parse(&quot;2025-04-30T18:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T18:00:00Z&quot;), Instant.parse(&quot;2025-04-30T20:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T20:00:00Z&quot;), Instant.parse(&quot;2025-04-30T22:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T22:00:00Z&quot;), Instant.parse(&quot;2025-05-01T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-30T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-30T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), Instant.parse(&quot;2025-04-30T10:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T10:00:00Z&quot;), Instant.parse(&quot;2025-04-30T12:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T12:00:00Z&quot;), Instant.parse(&quot;2025-04-30T14:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T14:00:00Z&quot;), Instant.parse(&quot;2025-04-30T16:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-30T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-30T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-30T00:00:00Z&quot;), Instant.parse(&quot;2025-04-30T02:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T02:00:00Z&quot;), Instant.parse(&quot;2025-04-30T04:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T04:00:00Z&quot;), Instant.parse(&quot;2025-04-30T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-30T06:00:00Z&quot;), Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-29T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-30T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-29T16:00:00Z&quot;), Instant.parse(&quot;2025-04-29T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T18:00:00Z&quot;), Instant.parse(&quot;2025-04-29T20:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T20:00:00Z&quot;), Instant.parse(&quot;2025-04-29T22:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T22:00:00Z&quot;), Instant.parse(&quot;2025-04-30T00:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-29T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-29T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), Instant.parse(&quot;2025-04-29T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T10:00:00Z&quot;), Instant.parse(&quot;2025-04-29T12:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T12:00:00Z&quot;), Instant.parse(&quot;2025-04-29T14:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T14:00:00Z&quot;), Instant.parse(&quot;2025-04-29T16:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-29T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-29T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-29T00:00:00Z&quot;), Instant.parse(&quot;2025-04-29T02:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T02:00:00Z&quot;), Instant.parse(&quot;2025-04-29T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T04:00:00Z&quot;), Instant.parse(&quot;2025-04-29T06:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-29T06:00:00Z&quot;), Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), SleepStageType.AWAKE)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-28T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-29T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-28T16:00:00Z&quot;), Instant.parse(&quot;2025-04-28T18:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T18:00:00Z&quot;), Instant.parse(&quot;2025-04-28T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T20:00:00Z&quot;), Instant.parse(&quot;2025-04-28T22:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T22:00:00Z&quot;), Instant.parse(&quot;2025-04-29T00:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-28T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-28T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), Instant.parse(&quot;2025-04-28T10:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T10:00:00Z&quot;), Instant.parse(&quot;2025-04-28T12:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T12:00:00Z&quot;), Instant.parse(&quot;2025-04-28T14:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T14:00:00Z&quot;), Instant.parse(&quot;2025-04-28T16:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-28T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-28T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-28T00:00:00Z&quot;), Instant.parse(&quot;2025-04-28T02:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T02:00:00Z&quot;), Instant.parse(&quot;2025-04-28T04:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T04:00:00Z&quot;), Instant.parse(&quot;2025-04-28T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-28T06:00:00Z&quot;), Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-27T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-28T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-27T16:00:00Z&quot;), Instant.parse(&quot;2025-04-27T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T18:00:00Z&quot;), Instant.parse(&quot;2025-04-27T20:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T20:00:00Z&quot;), Instant.parse(&quot;2025-04-27T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T22:00:00Z&quot;), Instant.parse(&quot;2025-04-28T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-27T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-27T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), Instant.parse(&quot;2025-04-27T10:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T10:00:00Z&quot;), Instant.parse(&quot;2025-04-27T12:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T12:00:00Z&quot;), Instant.parse(&quot;2025-04-27T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T14:00:00Z&quot;), Instant.parse(&quot;2025-04-27T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-27T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-27T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-27T00:00:00Z&quot;), Instant.parse(&quot;2025-04-27T02:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T02:00:00Z&quot;), Instant.parse(&quot;2025-04-27T04:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T04:00:00Z&quot;), Instant.parse(&quot;2025-04-27T06:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-27T06:00:00Z&quot;), Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-26T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-27T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-26T16:00:00Z&quot;), Instant.parse(&quot;2025-04-26T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T18:00:00Z&quot;), Instant.parse(&quot;2025-04-26T20:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T20:00:00Z&quot;), Instant.parse(&quot;2025-04-26T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T22:00:00Z&quot;), Instant.parse(&quot;2025-04-27T00:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-26T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-26T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), Instant.parse(&quot;2025-04-26T10:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T10:00:00Z&quot;), Instant.parse(&quot;2025-04-26T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T12:00:00Z&quot;), Instant.parse(&quot;2025-04-26T14:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T14:00:00Z&quot;), Instant.parse(&quot;2025-04-26T16:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-26T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-26T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-26T00:00:00Z&quot;), Instant.parse(&quot;2025-04-26T02:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T02:00:00Z&quot;), Instant.parse(&quot;2025-04-26T04:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T04:00:00Z&quot;), Instant.parse(&quot;2025-04-26T06:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-26T06:00:00Z&quot;), Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-25T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-26T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-25T16:00:00Z&quot;), Instant.parse(&quot;2025-04-25T18:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T18:00:00Z&quot;), Instant.parse(&quot;2025-04-25T20:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T20:00:00Z&quot;), Instant.parse(&quot;2025-04-25T22:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T22:00:00Z&quot;), Instant.parse(&quot;2025-04-26T00:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-25T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-25T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), Instant.parse(&quot;2025-04-25T10:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T10:00:00Z&quot;), Instant.parse(&quot;2025-04-25T12:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T12:00:00Z&quot;), Instant.parse(&quot;2025-04-25T14:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T14:00:00Z&quot;), Instant.parse(&quot;2025-04-25T16:00:00Z&quot;), SleepStageType.LIGHT)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-25T00:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-25T08:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-25T00:00:00Z&quot;), Instant.parse(&quot;2025-04-25T02:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T02:00:00Z&quot;), Instant.parse(&quot;2025-04-25T04:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T04:00:00Z&quot;), Instant.parse(&quot;2025-04-25T06:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-25T06:00:00Z&quot;), Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-24T16:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-25T00:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-24T16:00:00Z&quot;), Instant.parse(&quot;2025-04-24T18:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T18:00:00Z&quot;), Instant.parse(&quot;2025-04-24T20:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T20:00:00Z&quot;), Instant.parse(&quot;2025-04-24T22:00:00Z&quot;), SleepStageType.DEEP),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T22:00:00Z&quot;), Instant.parse(&quot;2025-04-25T00:00:00Z&quot;), SleepStageType.REM)&#10;            )&#10;        ),&#10;        SleepSession(&#10;            startTime = Instant.parse(&quot;2025-04-24T08:00:00Z&quot;),&#10;            endTime = Instant.parse(&quot;2025-04-24T16:00:00Z&quot;),&#10;            stages = listOf(&#10;                SleepStage(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), Instant.parse(&quot;2025-04-24T10:00:00Z&quot;), SleepStageType.AWAKE),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T10:00:00Z&quot;), Instant.parse(&quot;2025-04-24T12:00:00Z&quot;), SleepStageType.REM),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T12:00:00Z&quot;), Instant.parse(&quot;2025-04-24T14:00:00Z&quot;), SleepStageType.LIGHT),&#10;                SleepStage(Instant.parse(&quot;2025-04-24T14:00:00Z&quot;), Instant.parse(&quot;2025-04-24T16:00:00Z&quot;), SleepStageType.DEEP)&#10;            )&#10;        )&#10;    )&#10;&#10;    /**&#10;     * Sample weight data spanning 30 days&#10;     */&#10;    fun getWeightData(): List&lt;Weight&gt; = listOf(&#10;        Weight(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), Mass.kilograms(74.7)),&#10;        Weight(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), Mass.kilograms(68.6)),&#10;        Weight(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), Mass.kilograms(71.6)),&#10;        Weight(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), Mass.kilograms(74.2)),&#10;        Weight(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), Mass.kilograms(60.6)),&#10;        Weight(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), Mass.kilograms(73.8)),&#10;        Weight(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), Mass.kilograms(65.8)),&#10;        Weight(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), Mass.kilograms(73.2)),&#10;        Weight(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), Mass.kilograms(73.8)),&#10;        Weight(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), Mass.kilograms(67.5)),&#10;        Weight(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), Mass.kilograms(70.4)),&#10;        Weight(Instant.parse(&quot;2025-04-23T08:00:00Z&quot;), Mass.kilograms(61.4)),&#10;        Weight(Instant.parse(&quot;2025-04-22T08:00:00Z&quot;), Mass.kilograms(74.8)),&#10;        Weight(Instant.parse(&quot;2025-04-21T08:00:00Z&quot;), Mass.kilograms(66.1)),&#10;        Weight(Instant.parse(&quot;2025-04-20T08:00:00Z&quot;), Mass.kilograms(63.9)),&#10;        Weight(Instant.parse(&quot;2025-04-19T08:00:00Z&quot;), Mass.kilograms(67.9)),&#10;        Weight(Instant.parse(&quot;2025-04-18T08:00:00Z&quot;), Mass.kilograms(67.3)),&#10;        Weight(Instant.parse(&quot;2025-04-17T08:00:00Z&quot;), Mass.kilograms(66.8)),&#10;        Weight(Instant.parse(&quot;2025-04-16T08:00:00Z&quot;), Mass.kilograms(67.9)),&#10;        Weight(Instant.parse(&quot;2025-04-15T08:00:00Z&quot;), Mass.kilograms(66.4)),&#10;        Weight(Instant.parse(&quot;2025-04-14T08:00:00Z&quot;), Mass.kilograms(74.6)),&#10;        Weight(Instant.parse(&quot;2025-04-13T08:00:00Z&quot;), Mass.kilograms(66.1)),&#10;        Weight(Instant.parse(&quot;2025-04-12T08:00:00Z&quot;), Mass.kilograms(71.5)),&#10;        Weight(Instant.parse(&quot;2025-04-11T08:00:00Z&quot;), Mass.kilograms(72.9)),&#10;        Weight(Instant.parse(&quot;2025-04-10T08:00:00Z&quot;), Mass.kilograms(70.8)),&#10;        Weight(Instant.parse(&quot;2025-04-09T08:00:00Z&quot;), Mass.kilograms(69.9)),&#10;        Weight(Instant.parse(&quot;2025-04-08T08:00:00Z&quot;), Mass.kilograms(60.9)),&#10;        Weight(Instant.parse(&quot;2025-04-07T08:00:00Z&quot;), Mass.kilograms(66.9)),&#10;        Weight(Instant.parse(&quot;2025-04-06T08:00:00Z&quot;), Mass.kilograms(69.3)),&#10;        Weight(Instant.parse(&quot;2025-04-05T08:00:00Z&quot;), Mass.kilograms(61.1))&#10;    )&#10;&#10;    fun getBodyFatData(): List&lt;BodyFat&gt; = listOf(&#10;        BodyFat(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), 22.1),&#10;        BodyFat(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), 24.2),&#10;        BodyFat(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), 20.7),&#10;        BodyFat(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), 18.3),&#10;        BodyFat(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), 20.9),&#10;        BodyFat(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), 15.3),&#10;        BodyFat(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), 18.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), 19.4),&#10;        BodyFat(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), 18.3),&#10;        BodyFat(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), 19.8),&#10;        BodyFat(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), 21.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-23T08:00:00Z&quot;), 22.1),&#10;        BodyFat(Instant.parse(&quot;2025-04-22T08:00:00Z&quot;), 22.4),&#10;        BodyFat(Instant.parse(&quot;2025-04-21T08:00:00Z&quot;), 21.6),&#10;        BodyFat(Instant.parse(&quot;2025-04-20T08:00:00Z&quot;), 19.2),&#10;        BodyFat(Instant.parse(&quot;2025-04-19T08:00:00Z&quot;), 20.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-18T08:00:00Z&quot;), 17.9),&#10;        BodyFat(Instant.parse(&quot;2025-04-17T08:00:00Z&quot;), 16.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-16T08:00:00Z&quot;), 15.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-15T08:00:00Z&quot;), 14.4),&#10;        BodyFat(Instant.parse(&quot;2025-04-14T08:00:00Z&quot;), 18.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-13T08:00:00Z&quot;), 16.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-12T08:00:00Z&quot;), 17.5),&#10;        BodyFat(Instant.parse(&quot;2025-04-11T08:00:00Z&quot;), 12.0),&#10;        BodyFat(Instant.parse(&quot;2025-04-10T08:00:00Z&quot;), 14.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-09T08:00:00Z&quot;), 11.8),&#10;        BodyFat(Instant.parse(&quot;2025-04-08T08:00:00Z&quot;), 13.7),&#10;        BodyFat(Instant.parse(&quot;2025-04-07T08:00:00Z&quot;), 13.1),&#10;        BodyFat(Instant.parse(&quot;2025-04-06T08:00:00Z&quot;), 13.2),&#10;        BodyFat(Instant.parse(&quot;2025-04-05T08:00:00Z&quot;), 12.9)&#10;    )&#10;&#10;    fun getBloodPressureData(): List&lt;BloodPressure&gt; = listOf(&#10;        BloodPressure(Instant.parse(&quot;2025-05-04T08:00:00Z&quot;), 119.5, 73.3),&#10;        BloodPressure(Instant.parse(&quot;2025-05-03T08:00:00Z&quot;), 123.4, 82.6),&#10;        BloodPressure(Instant.parse(&quot;2025-05-02T08:00:00Z&quot;), 115.2, 84.9),&#10;        BloodPressure(Instant.parse(&quot;2025-05-01T08:00:00Z&quot;), 128.2, 81.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-30T08:00:00Z&quot;), 129.3, 71.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-29T08:00:00Z&quot;), 118.5, 79.6),&#10;        BloodPressure(Instant.parse(&quot;2025-04-28T08:00:00Z&quot;), 120.4, 71.5),&#10;        BloodPressure(Instant.parse(&quot;2025-04-27T08:00:00Z&quot;), 113.1, 80.9),&#10;        BloodPressure(Instant.parse(&quot;2025-04-26T08:00:00Z&quot;), 112.8, 82.1),&#10;        BloodPressure(Instant.parse(&quot;2025-04-25T08:00:00Z&quot;), 114.9, 79.3),&#10;        BloodPressure(Instant.parse(&quot;2025-04-24T08:00:00Z&quot;), 124.3, 70.1),&#10;        BloodPressure(Instant.parse(&quot;2025-04-23T08:00:00Z&quot;), 123.1, 82.6),&#10;        BloodPressure(Instant.parse(&quot;2025-04-22T08:00:00Z&quot;), 123.4, 82.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-21T08:00:00Z&quot;), 122.0, 80.9),&#10;        BloodPressure(Instant.parse(&quot;2025-04-20T08:00:00Z&quot;), 118.8, 80.4),&#10;        BloodPressure(Instant.parse(&quot;2025-04-19T08:00:00Z&quot;), 123.2, 76.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-18T08:00:00Z&quot;), 113.0, 84.4),&#10;        BloodPressure(Instant.parse(&quot;2025-04-17T08:00:00Z&quot;), 115.5, 82.6),&#10;        BloodPressure(Instant.parse(&quot;2025-04-16T08:00:00Z&quot;), 123.9, 83.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-15T08:00:00Z&quot;), 111.4, 79.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-14T08:00:00Z&quot;), 119.5, 84.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-13T08:00:00Z&quot;), 114.1, 71.0),&#10;        BloodPressure(Instant.parse(&quot;2025-04-12T08:00:00Z&quot;), 116.1, 81.9),&#10;        BloodPressure(Instant.parse(&quot;2025-04-11T08:00:00Z&quot;), 121.9, 76.5),&#10;        BloodPressure(Instant.parse(&quot;2025-04-10T08:00:00Z&quot;), 123.9, 73.0),&#10;        BloodPressure(Instant.parse(&quot;2025-04-09T08:00:00Z&quot;), 119.1, 83.1),&#10;        BloodPressure(Instant.parse(&quot;2025-04-08T08:00:00Z&quot;), 129.2, 72.8),&#10;        BloodPressure(Instant.parse(&quot;2025-04-07T08:00:00Z&quot;), 123.4, 78.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-06T08:00:00Z&quot;), 126.2, 76.2),&#10;        BloodPressure(Instant.parse(&quot;2025-04-05T08:00:00Z&quot;), 111.5, 84.7)&#10;    )&#10;&#10;    /**&#10;     * Sample heart rate range data for range bar charts&#10;     * Returns List&lt;ChartPoint&gt; where multiple points with same x-value represent min and max values&#10;     */&#10;    fun getHeartRateRangeData(): List&lt;ChartPoint&gt; = listOf(&#10;        // Day 2 (x = 0)&#10;        ChartPoint(x = 0f, y = 54f, label = &quot;2일&quot;), // min&#10;        ChartPoint(x = 0f, y = 160f, label = &quot;2일&quot;), // max&#10;&#10;        // Day 3 (x = 1)&#10;        ChartPoint(x = 1f, y = 65f, label = &quot;3일&quot;), // min&#10;        ChartPoint(x = 1f, y = 145f, label = &quot;3일&quot;), // max&#10;&#10;        // Day 4 (x = 2)&#10;        ChartPoint(x = 2f, y = 58f, label = &quot;4일&quot;), // min&#10;        ChartPoint(x = 2f, y = 125f, label = &quot;4일&quot;), // max&#10;&#10;        // Day 6 (x = 3)&#10;        ChartPoint(x = 3f, y = 75f, label = &quot;6일&quot;), // min&#10;        ChartPoint(x = 3f, y = 110f, label = &quot;6일&quot;), // max&#10;&#10;        // Day 7 (x = 4)&#10;        ChartPoint(x = 4f, y = 68f, label = &quot;7일&quot;), // min&#10;        ChartPoint(x = 4f, y = 162f, label = &quot;7일&quot;), // max&#10;&#10;        // Day 8 (x = 5)&#10;        ChartPoint(x = 5f, y = 72f, label = &quot;8일&quot;), // min&#10;        ChartPoint(x = 5f, y = 168f, label = &quot;8일&quot;), // max&#10;&#10;        // Day 9 (x = 6)&#10;        ChartPoint(x = 6f, y = 65f, label = &quot;9일&quot;), // min&#10;        ChartPoint(x = 6f, y = 138f, label = &quot;9일&quot;), // max&#10;&#10;        // Day 10 (x = 7)&#10;        ChartPoint(x = 7f, y = 85f, label = &quot;10일&quot;), // min&#10;        ChartPoint(x = 7f, y = 105f, label = &quot;10일&quot;) // max&#10;    )&#10;&#10;    /**&#10;     * Sample nutrition data for stacked bar charts (protein, fat, carbs)&#10;     * Returns List&lt;ChartPoint&gt; where multiple points with same x-value represent different segments&#10;     */&#10;    fun getNutritionStackedData(): List&lt;ChartPoint&gt; = listOf(&#10;        // Monday (x = 0)&#10;        ChartPoint(x = 0f, y = 80f, label = &quot;월&quot;),&#10;        ChartPoint(x = 0f, y = 45f, label = &quot;월&quot;),&#10;        ChartPoint(x = 0f, y = 120f, label = &quot;월&quot;),&#10;&#10;        // Tuesday (x = 1)&#10;        ChartPoint(x = 1f, y = 75f, label = &quot;화&quot;),&#10;        ChartPoint(x = 1f, y = 38f, label = &quot;화&quot;),&#10;        ChartPoint(x = 1f, y = 110f, label = &quot;화&quot;),&#10;&#10;        // Wednesday (x = 2)&#10;        ChartPoint(x = 2f, y = 90f, label = &quot;수&quot;),&#10;        ChartPoint(x = 2f, y = 52f, label = &quot;수&quot;),&#10;        ChartPoint(x = 2f, y = 140f, label = &quot;수&quot;),&#10;&#10;        // Thursday (x = 3)&#10;        ChartPoint(x = 3f, y = 85f, label = &quot;목&quot;),&#10;        ChartPoint(x = 3f, y = 41f, label = &quot;목&quot;),&#10;        ChartPoint(x = 3f, y = 135f, label = &quot;목&quot;),&#10;&#10;        // Friday (x = 4)&#10;        ChartPoint(x = 4f, y = 95f, label = &quot;금&quot;),&#10;        ChartPoint(x = 4f, y = 58f, label = &quot;금&quot;),&#10;        ChartPoint(x = 4f, y = 150f, label = &quot;금&quot;),&#10;&#10;        // Saturday (x = 5)&#10;        ChartPoint(x = 5f, y = 70f, label = &quot;토&quot;),&#10;        ChartPoint(x = 5f, y = 35f, label = &quot;토&quot;),&#10;        ChartPoint(x = 5f, y = 100f, label = &quot;토&quot;),&#10;&#10;        // Sunday (x = 6)&#10;        ChartPoint(x = 6f, y = 88f, label = &quot;일&quot;),&#10;        ChartPoint(x = 6f, y = 48f, label = &quot;일&quot;),&#10;        ChartPoint(x = 6f, y = 125f, label = &quot;일&quot;)&#10;    )&#10;&#10;    /**&#10;     * Sample progress data for Apple Watch-style activity rings&#10;     */&#10;    fun getActivityProgressData(): List&lt;ProgressChartPoint&gt; = listOf(&#10;        ProgressChartPoint(x = 0f, current = 1200f, max = 2000f, label = &quot;Move&quot;, unit = &quot;KJ&quot;),&#10;        ProgressChartPoint(x = 1f, current = 20f, max = 60f, label = &quot;Exercise&quot;, unit = &quot;min&quot;),&#10;        ProgressChartPoint(x = 2f, current = 7f, max = 10f, label = &quot;Stand&quot;, unit = &quot;h&quot;)&#10;    )&#10;&#10;    /**&#10;     * Sample calendar entries for calendar charts&#10;     */&#10;    fun getCalendarEntries(yearMonth: YearMonth = YearMonth.now()): List&lt;CalendarEntry&gt; {&#10;        val startDate = LocalDate.of(yearMonth.year, yearMonth.monthValue, 1)&#10;        val endDate = LocalDate.of(yearMonth.year, yearMonth.monthValue, yearMonth.lengthOfMonth())&#10;        val random = java.util.Random(0)&#10;        &#10;        return generateSequence(startDate) { date -&gt;&#10;            if (date.isBefore(endDate)) date.plusDays(1) else null&#10;        }.map { date -&gt;&#10;            val value = random.nextFloat() * 100&#10;            CalendarEntry(date = date, value = value)&#10;        }.toList()&#10;    }&#10;&#10;    /**&#10;     * Convert basic sample data to ChartPoint format&#10;     */&#10;    fun getBasicChartPoints(): List&lt;ChartPoint&gt; = sampleData.mapIndexed { index, value -&gt;&#10;        ChartPoint(x = index.toFloat(), y = value, label = weekDays.getOrElse(index) { &quot;&quot; })&#10;    }&#10;&#10;    /**&#10;     * Convert extended sample data to ChartPoint format (for pagination demos)&#10;     */&#10;    fun getExtendedChartPoints(): List&lt;ChartPoint&gt; = sampleData4.mapIndexed { index, value -&gt;&#10;        ChartPoint(x = index.toFloat(), y = value, label = weekDays[index % weekDays.size])&#10;    }&#10;&#10;    /**&#10;     * Generate dense chart points for tick reduction demos&#10;     */&#10;    fun getDenseChartPoints(count: Int = 50): List&lt;ChartPoint&gt; {&#10;        val labels = (1..count).map { &quot;Day $it&quot; }&#10;        val values = (1..count).map { (20..80).random().toFloat() }&#10;        return labels.mapIndexed { index, label -&gt;&#10;            ChartPoint(x = index.toFloat(), y = values[index], label = label)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get blood pressure data as separate ChartPoint lists for systolic and diastolic&#10;     * Uses the transform convenience function for proper time-based processing&#10;     */&#10;    fun getBloodPressureChartPointsMap(): Map&lt;String, List&lt;ChartPoint&gt;&gt; {&#10;        return getBloodPressureData().transform(&#10;            timeUnit = TimeUnitGroup.DAY,&#10;            aggregationType = AggregationType.DAILY_AVERAGE&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>