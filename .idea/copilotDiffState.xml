<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/RangeBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/RangeBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.YAxisPosition&#10;import com.hdil.saluschart.core.transform.toRangeChartPoints&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun RangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;, &#10;    title: String = &quot;Range Bar Chart&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    barWidthRatio: Float = 0.6f,&#10;    yAxisPosition: YAxisPosition = YAxisPosition.LEFT, // Y축 위치&#10;    interactionType: InteractionType.RangeBar = InteractionType.RangeBar.BAR,&#10;    onBarClick: ((Int, RangeChartPoint) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.RANGE_BAR,&#10;    windowSize: Int? = null, // 윈도우 크기 (null이면 전체 화면)&#10;    maxXTicksLimit: Int? = null,             // X축에 표시할 최대 라벨 개수 (null이면 모든 라벨 표시)&#10;    unit: String = &quot;&quot; // 단위 (예: &quot;kg&quot;, &quot;bpm&quot; 등)&#10;) {&#10;    if (data.isEmpty()) return&#10;    &#10;    // Transform ChartPoints to RangeChartPoints automatically&#10;    val rangeData = data.toRangeChartPoints(&#10;        minValueSelector = { group: List&lt;ChartPoint&gt; -&gt; group.minByOrNull { it.y } ?: group.first() },&#10;        maxValueSelector = { group: List&lt;ChartPoint&gt; -&gt; group.maxByOrNull { it.y } ?: group.first() }&#10;    )&#10;&#10;    val useScrolling = windowSize != null &amp;&amp; windowSize &lt; rangeData.size&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        BoxWithConstraints {&#10;            val availableWidth = maxWidth&#10;            val marginHorizontal = 16.dp&#10;&#10;            val canvasWidth = if(useScrolling) {&#10;                // 스크롤 모드: 좌우 마진을 고려한 실제 차트 너비 계산&#10;                val chartWidth = availableWidth - (marginHorizontal * 2) // 좌우 마진 제외&#10;                val sectionsCount = (rangeData.size.toFloat() / windowSize!!.toFloat()).toInt()&#10;                val totalWidth = chartWidth * sectionsCount&#10;                totalWidth&#10;            } else {&#10;                // 일반 모드: 전체 데이터를 화면에 맞춤&#10;                null&#10;            }&#10;&#10;            val labels = rangeData.map { rangePoint -&gt; rangePoint.label ?: rangePoint.x.toString() }&#10;            var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;            var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;            Box(&#10;                modifier = if (useScrolling) {&#10;                    Modifier&#10;                        .horizontalScroll(&#10;                            scrollState,&#10;                            overscrollEffect = null&#10;                        )&#10;                        .padding(horizontal = marginHorizontal)&#10;                } else {&#10;                    modifier&#10;                }&#10;            ) {&#10;                Canvas(&#10;                    modifier = if (useScrolling) {&#10;                        Modifier&#10;                            .width(canvasWidth!!) // 계산된 캔버스 너비 사용&#10;                            .fillMaxHeight()&#10;                    } else {&#10;                        Modifier.fillMaxSize()&#10;                    }&#10;                ) {&#10;                    val metrics = ChartMath.RangeBar.computeRangeMetrics(size, rangeData)&#10;                    chartMetrics = metrics&#10;&#10;                    ChartDraw.drawGrid(this, size, metrics, yAxisPosition)&#10;                    ChartDraw.drawYAxis(this, metrics, yAxisPosition)&#10;                    ChartDraw.Bar.drawBarXAxisLabels(drawContext, labels, metrics, maxXTicksLimit = maxXTicksLimit)&#10;                }&#10;&#10;                // Conditional interaction based on interactionType parameter&#10;                when (interactionType) {&#10;                    InteractionType.RangeBar.BAR -&gt; {&#10;                        // Interactive range bars&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = rangeData.map { rangePoint -&gt; rangePoint.minPoint.y },&#10;                                maxValues = rangeData.map { rangePoint -&gt; rangePoint.maxPoint.y },&#10;                                metrics = metrics,&#10;                                color = barColor,&#10;                                barWidthRatio = barWidthRatio,&#10;                                interactive = true,&#10;                                onBarClick = { index, tooltipText -&gt;&#10;                                    selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                    onBarClick?.invoke(index, rangeData[index])&#10;                                },&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedBarIndex,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;                    }&#10;                    InteractionType.RangeBar.TOUCH_AREA -&gt; {&#10;                        // Non-interactive range bars&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = rangeData.map { rangePoint -&gt; rangePoint.minPoint.y },&#10;                                maxValues = rangeData.map { rangePoint -&gt; rangePoint.maxPoint.y },&#10;                                metrics = metrics,&#10;                                color = barColor,&#10;                                barWidthRatio = barWidthRatio,&#10;                                interactive = false,&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedBarIndex,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = List(rangeData.size) { metrics.minY },&#10;                                maxValues = rangeData.map { rangePoint -&gt; rangePoint.maxPoint.y },&#10;                                metrics = metrics,&#10;                                onBarClick = { index: Int, _: String -&gt;&#10;                                    selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                    onBarClick?.invoke(index, rangeData[index])&#10;                                },&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedBarIndex,&#10;                                isTouchArea = true,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Default case - no interaction&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = rangeData.map { it.minPoint.y },&#10;                                maxValues = rangeData.map { it.maxPoint.y },&#10;                                metrics = metrics,&#10;                                color = barColor,&#10;                                barWidthRatio = barWidthRatio,&#10;                                interactive = false,&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = null,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.YAxisPosition&#10;import com.hdil.saluschart.core.transform.toRangeChartPoints&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun RangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;, &#10;    title: String = &quot;Range Bar Chart&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    barWidthRatio: Float = 0.6f,&#10;    yAxisPosition: YAxisPosition = YAxisPosition.LEFT, // Y축 위치&#10;    interactionType: InteractionType.RangeBar = InteractionType.RangeBar.BAR,&#10;    onBarClick: ((Int, RangeChartPoint) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.RANGE_BAR,&#10;    windowSize: Int? = null, // 윈도우 크기 (null이면 전체 화면)&#10;    maxXTicksLimit: Int? = null,             // X축에 표시할 최대 라벨 개수 (null이면 모든 라벨 표시)&#10;    unit: String = &quot;&quot; // 단위 (예: &quot;kg&quot;, &quot;bpm&quot; 등)&#10;) {&#10;    if (data.isEmpty()) return&#10;    &#10;    // Transform ChartPoints to RangeChartPoints automatically&#10;    val rangeData = data.toRangeChartPoints(&#10;        minValueSelector = { group: List&lt;ChartPoint&gt; -&gt; group.minByOrNull { it.y } ?: group.first() },&#10;        maxValueSelector = { group: List&lt;ChartPoint&gt; -&gt; group.maxByOrNull { it.y } ?: group.first() }&#10;    )&#10;&#10;    val useScrolling = windowSize != null &amp;&amp; windowSize &lt; rangeData.size&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        BoxWithConstraints {&#10;            val availableWidth = maxWidth&#10;            val marginHorizontal = 16.dp&#10;&#10;            val canvasWidth = if(useScrolling) {&#10;                // 스크롤 모드: 좌우 마진을 고려한 실제 차트 너비 계산&#10;                val chartWidth = availableWidth - (marginHorizontal * 2) // 좌우 마진 제외&#10;                val sectionsCount = (rangeData.size.toFloat() / windowSize!!.toFloat()).toInt()&#10;                val totalWidth = chartWidth * sectionsCount&#10;                totalWidth&#10;            } else {&#10;                // 일반 모드: 전체 데이터를 화면에 맞춤&#10;                null&#10;            }&#10;&#10;            val labels = rangeData.map { rangePoint -&gt; rangePoint.label ?: rangePoint.x.toString() }&#10;            var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;            var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;            Box(&#10;                modifier = if (useScrolling) {&#10;                    Modifier&#10;                        .horizontalScroll(&#10;                            scrollState,&#10;                            overscrollEffect = null&#10;                        )&#10;                        .padding(horizontal = marginHorizontal)&#10;                } else {&#10;                    modifier&#10;                }&#10;            ) {&#10;                Canvas(&#10;                    modifier = if (useScrolling) {&#10;                        Modifier&#10;                            .width(canvasWidth!!) // 계산된 캔버스 너비 사용&#10;                            .fillMaxHeight()&#10;                    } else {&#10;                        Modifier.fillMaxSize()&#10;                    }&#10;                ) {&#10;                    val metrics = ChartMath.RangeBar.computeRangeMetrics(size, rangeData)&#10;                    chartMetrics = metrics&#10;&#10;                    ChartDraw.drawGrid(this, size, metrics, yAxisPosition)&#10;                    ChartDraw.drawYAxis(this, metrics, yAxisPosition)&#10;                    ChartDraw.Bar.drawBarXAxisLabels(drawContext, labels, metrics, maxXTicksLimit = maxXTicksLimit)&#10;                }&#10;&#10;                // Conditional interaction based on interactionType parameter&#10;                when (interactionType) {&#10;                    InteractionType.RangeBar.BAR -&gt; {&#10;                        // Interactive range bars&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = rangeData.map { rangePoint -&gt; rangePoint.minPoint.y },&#10;                                maxValues = rangeData.map { rangePoint -&gt; rangePoint.maxPoint.y },&#10;                                metrics = metrics,&#10;                                color = barColor,&#10;                                barWidthRatio = barWidthRatio,&#10;                                interactive = true,&#10;                                onBarClick = { index, tooltipText -&gt;&#10;                                    selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                    onBarClick?.invoke(index, rangeData[index])&#10;                                },&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedBarIndex,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;                    }&#10;                    InteractionType.RangeBar.TOUCH_AREA -&gt; {&#10;                        // Non-interactive range bars&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = rangeData.map { rangePoint -&gt; rangePoint.minPoint.y },&#10;                                maxValues = rangeData.map { rangePoint -&gt; rangePoint.maxPoint.y },&#10;                                metrics = metrics,&#10;                                color = barColor,&#10;                                barWidthRatio = barWidthRatio,&#10;                                interactive = false,&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedBarIndex,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = List(rangeData.size) { metrics.minY },&#10;                                maxValues = rangeData.map { rangePoint -&gt; rangePoint.maxPoint.y },&#10;                                metrics = metrics,&#10;                                onBarClick = { index: Int, _: String -&gt;&#10;                                    selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                    onBarClick?.invoke(index, rangeData[index])&#10;                                },&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedBarIndex,&#10;                                isTouchArea = true,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        // Default case - no interaction&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = rangeData,&#10;                                minValues = rangeData.map { it.minPoint.y },&#10;                                maxValues = rangeData.map { it.maxPoint.y },&#10;                                metrics = metrics,&#10;                                color = barColor,&#10;                                barWidthRatio = barWidthRatio,&#10;                                interactive = false,&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = null,&#10;                                unit = unit&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>