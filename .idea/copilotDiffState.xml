<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/transform/src/main/java/com/hdil/saluschart/core/transform/TimeDataPoint.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/transform/src/main/java/com/hdil/saluschart/core/transform/TimeDataPoint.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.transform&#10;&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.util.AggregationType&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.time.ZoneId&#10;import java.time.temporal.TemporalAdjusters&#10;import java.time.DayOfWeek&#10;&#10;&#10;/**&#10; * 시간 기반 원시 데이터 포인트&#10; * ChartPoint로 변환해서 사용&#10; * @param x 시간 데이터 (Instant 타입)&#10; * @param y 측정값 리스트 (단일 값용)&#10; * @param yMultiple 다중 측정값 맵 (다중 값용) - 키는 속성명, 값은 해당 속성의 값 리스트&#10; * @param timeUnit 시간 단위&#10; */&#10;data class TimeDataPoint(&#10;    val x : List&lt;Instant&gt;,&#10;    val y : List&lt;Float&gt;? = null,&#10;    val yMultiple : Map&lt;String, List&lt;Float&gt;&gt;? = null,&#10;    val timeUnit : TimeUnitGroup = TimeUnitGroup.HOUR&#10;) {&#10;    init {&#10;        require((y != null) xor (yMultiple != null)) {&#10;            &quot;Either y or yMultiple must be provided, but not both&quot;&#10;        }&#10;        &#10;        if (y != null) {&#10;            require(x.size == y.size) {&#10;                &quot;x and y lists must have the same size&quot;&#10;            }&#10;        }&#10;        &#10;        if (yMultiple != null) {&#10;            require(yMultiple.isNotEmpty()) {&#10;                &quot;yMultiple cannot be empty&quot;&#10;            }&#10;            yMultiple.values.forEach { valueList -&gt;&#10;                require(x.size == valueList.size) {&#10;                    &quot;All value lists in yMultiple must have the same size as x&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    val isSingleValue: Boolean get() = y != null     // 단일 값 여부 확인&#10;    val isMultiValue: Boolean get() = yMultiple != null    // 다중 값 여부 확인&#10;    fun getValues(property: String): List&lt;Float&gt;? = yMultiple?.get(property)    // 다중 값에서 특정 속성의 값 가져오기&#10;    val propertyNames: Set&lt;String&gt; get() = yMultiple?.keys ?: emptySet()    // 다중 값의 속성명 목록 가져오기&#10;}&#10;&#10;/**&#10; * TimeDataPoint를 ChartPoint 리스트로 변환하는 확장 함수&#10; * 단일 값 데이터용&#10; *&#10; * @return ChartPoint 리스트&#10; *&#10; * 각 시간 단위에 따라 레이블이 생성됩니다:&#10; * HOUR: &quot;14시&quot; (for 2 PM)&#10; * DAY: &quot;5/8 월&quot; (for May 8th Monday, includes day of week)&#10; * WEEK: &quot;5월 1주차&quot; (for first week of May)&#10; * MONTH: &quot;2025년 5월&quot; (for May 2025)&#10; * YEAR: &quot;2025년&quot; (for year 2025)&#10; */&#10;fun TimeDataPoint.toChartPoints(): List&lt;ChartPoint&gt; {&#10;    require(isSingleValue) { &quot;Use toChartPointsByProperty() for multi-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = y!![index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint에서 특정 속성을 추출하여 ChartPoint 리스트로 변환하는 확장 함수&#10; *&#10; * @param property 추출할 속성명 (예: &quot;systolic&quot;, &quot;diastolic&quot;, &quot;calories&quot;, &quot;protein&quot; 등)&#10; * @return 해당 속성의 ChartPoint 리스트&#10; */&#10;fun TimeDataPoint.toChartPointsByProperty(property: String): List&lt;ChartPoint&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    require(propertyNames.contains(property)) { &#10;        &quot;Property '$property' not found. Available properties: ${propertyNames.joinToString()}&quot; &#10;    }&#10;    &#10;    val values = getValues(property)!!&#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = values[index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint를 모든 속성별로 분리된 ChartPoint 맵으로 변환하는 확장 함수&#10; *&#10; * @return 속성명을 키로 하고 해당 속성의 ChartPoint 리스트를 값으로 하는 맵&#10; */&#10;fun TimeDataPoint.toChartPointsMap(): Map&lt;String, List&lt;ChartPoint&gt;&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;    &#10;    return propertyNames.associateWith { property -&gt;&#10;        val values = getValues(property)!!&#10;        x.indices.map { index -&gt;&#10;            ChartPoint(&#10;                x = index.toFloat(),&#10;                y = values[index],&#10;                label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 시간 단위에 따른 레이블 생성 (공통 로직)&#10; */&#10;private fun TimeDataPoint.generateTimeLabels(): List&lt;String&gt; {&#10;    return when (timeUnit) {&#10;        TimeUnitGroup.MINUTE -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}:${dateTime.minute.toString().padStart(2, '0')}&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.HOUR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}시&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.DAY -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val dayOfWeekKorean = when (dateTime.dayOfWeek.value) {&#10;                    1 -&gt; &quot;월&quot;&#10;                    2 -&gt; &quot;화&quot;&#10;                    3 -&gt; &quot;수&quot;&#10;                    4 -&gt; &quot;목&quot;&#10;                    5 -&gt; &quot;금&quot;&#10;                    6 -&gt; &quot;토&quot;&#10;                    7 -&gt; &quot;일&quot;&#10;                    else -&gt; &quot;?&quot;&#10;                }&#10;                &quot;${dateTime.monthValue}/${dateTime.dayOfMonth} $dayOfWeekKorean&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.WEEK -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val sunday = dateTime.toLocalDate().with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY))&#10;                val firstSundayOfMonth = LocalDate.of(sunday.year, sunday.month, 1)&#10;                    .let { firstDay -&gt;&#10;                        val dayOfWeek = firstDay.dayOfWeek.value&#10;                        if (dayOfWeek == 7) firstDay else firstDay.plusDays((7 - dayOfWeek).toLong())&#10;                    }&#10;                val weekNumber = ((sunday.toEpochDay() - firstSundayOfMonth.toEpochDay()) / 7 + 1).toInt()&#10;                &quot;${sunday.monthValue}월 ${weekNumber}주차&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.MONTH -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년 ${dateTime.monthValue}월&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.YEAR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년&quot;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.transform&#10;&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.util.AggregationType&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.time.ZoneId&#10;import java.time.temporal.TemporalAdjusters&#10;import java.time.DayOfWeek&#10;&#10;&#10;/**&#10; * 시간 기반 원시 데이터 포인트&#10; * ChartPoint로 변환해서 사용&#10; * @param x 시간 데이터 (Instant 타입)&#10; * @param y 측정값 리스트 (단일 값용)&#10; * @param yMultiple 다중 측정값 맵 (다중 값용) - 키는 속성명, 값은 해당 속성의 값 리스트&#10; * @param timeUnit 시간 단위&#10; */&#10;data class TimeDataPoint(&#10;    val x : List&lt;Instant&gt;,&#10;    val y : List&lt;Float&gt;? = null,&#10;    val yMultiple : Map&lt;String, List&lt;Float&gt;&gt;? = null,&#10;    val timeUnit : TimeUnitGroup = TimeUnitGroup.HOUR&#10;) {&#10;    init {&#10;        require((y != null) xor (yMultiple != null)) {&#10;            &quot;Either y or yMultiple must be provided, but not both&quot;&#10;        }&#10;        &#10;        if (y != null) {&#10;            require(x.size == y.size) {&#10;                &quot;x and y lists must have the same size&quot;&#10;            }&#10;        }&#10;        &#10;        if (yMultiple != null) {&#10;            require(yMultiple.isNotEmpty()) {&#10;                &quot;yMultiple cannot be empty&quot;&#10;            }&#10;            yMultiple.values.forEach { valueList -&gt;&#10;                require(x.size == valueList.size) {&#10;                    &quot;All value lists in yMultiple must have the same size as x&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    val isSingleValue: Boolean get() = y != null     // 단일 값 여부 확인&#10;    val isMultiValue: Boolean get() = yMultiple != null    // 다중 값 여부 확인&#10;    fun getValues(property: String): List&lt;Float&gt;? = yMultiple?.get(property)    // 다중 값에서 특정 속성의 값 가져오기&#10;    val propertyNames: Set&lt;String&gt; get() = yMultiple?.keys ?: emptySet()    // 다중 값의 속성명 목록 가져오기&#10;}&#10;&#10;/**&#10; * TimeDataPoint를 ChartPoint 리스트로 변환하는 확장 함수&#10; * 단일 값 데이터용&#10; *&#10; * @return ChartPoint 리스트&#10; *&#10; * 각 시간 단위에 따라 레이블이 생성됩니다:&#10; * HOUR: &quot;14시&quot; (for 2 PM)&#10; * DAY: &quot;5/8 월&quot; (for May 8th Monday, includes day of week)&#10; * WEEK: &quot;5월 1주차&quot; (for first week of May)&#10; * MONTH: &quot;2025년 5월&quot; (for May 2025)&#10; * YEAR: &quot;2025년&quot; (for year 2025)&#10; */&#10;fun TimeDataPoint.toChartPoints(): List&lt;ChartPoint&gt; {&#10;    require(isSingleValue) { &quot;Use toChartPointsByProperty() for multi-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = y!![index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint에서 특정 속성을 추출하여 ChartPoint 리스트로 변환하는 확장 함수&#10; *&#10; * @param property 추출할 속성명 (예: &quot;systolic&quot;, &quot;diastolic&quot;, &quot;calories&quot;, &quot;protein&quot; 등)&#10; * @return 해당 속성의 ChartPoint 리스트&#10; */&#10;fun TimeDataPoint.toChartPointsByProperty(property: String): List&lt;ChartPoint&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    require(propertyNames.contains(property)) { &#10;        &quot;Property '$property' not found. Available properties: ${propertyNames.joinToString()}&quot; &#10;    }&#10;    &#10;    val values = getValues(property)!!&#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = values[index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint를 모든 속성별로 분리된 ChartPoint 맵으로 변환하는 확장 함수&#10; *&#10; * @return 속성명을 키로 하고 해당 속성의 ChartPoint 리스트를 값으로 하는 맵&#10; */&#10;fun TimeDataPoint.toChartPointsMap(): Map&lt;String, List&lt;ChartPoint&gt;&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;    &#10;    return propertyNames.associateWith { property -&gt;&#10;        val values = getValues(property)!!&#10;        x.indices.map { index -&gt;&#10;            ChartPoint(&#10;                x = index.toFloat(),&#10;                y = values[index],&#10;                label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 시간 단위에 따른 레이블 생성 (공통 로직)&#10; */&#10;private fun TimeDataPoint.generateTimeLabels(): List&lt;String&gt; {&#10;    return when (timeUnit) {&#10;        TimeUnitGroup.MINUTE -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}:${dateTime.minute.toString().padStart(2, '0')}&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.HOUR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}시&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.DAY -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val dayOfWeekKorean = when (dateTime.dayOfWeek.value) {&#10;                    1 -&gt; &quot;월&quot;&#10;                    2 -&gt; &quot;화&quot;&#10;                    3 -&gt; &quot;수&quot;&#10;                    4 -&gt; &quot;목&quot;&#10;                    5 -&gt; &quot;금&quot;&#10;                    6 -&gt; &quot;토&quot;&#10;                    7 -&gt; &quot;일&quot;&#10;                    else -&gt; &quot;?&quot;&#10;                }&#10;                &quot;${dateTime.monthValue}/${dateTime.dayOfMonth} $dayOfWeekKorean&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.WEEK -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val sunday = dateTime.toLocalDate().with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY))&#10;                val firstSundayOfMonth = LocalDate.of(sunday.year, sunday.month, 1)&#10;                    .let { firstDay -&gt;&#10;                        val dayOfWeek = firstDay.dayOfWeek.value&#10;                        if (dayOfWeek == 7) firstDay else firstDay.plusDays((7 - dayOfWeek).toLong())&#10;                    }&#10;                val weekNumber = ((sunday.toEpochDay() - firstSundayOfMonth.toEpochDay()) / 7 + 1).toInt()&#10;                &quot;${sunday.monthValue}월 ${weekNumber}주차&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.MONTH -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년 ${dateTime.monthValue}월&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.YEAR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년&quot;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>