<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/build.gradle.kts" />
              <option name="originalContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;    implementation(project(&quot;:data:model&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;    implementation(libs.androidx.foundation.layout)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;&#10;    // compose shape&#10;    implementation(&quot;androidx.graphics:graphics-shapes:1.0.1&quot;)&#10;}" />
              <option name="updatedContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;    implementation(project(&quot;:data:model&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;    implementation(libs.androidx.foundation.layout)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;&#10;    // compose shape&#10;    implementation(&quot;androidx.graphics:graphics-shapes:1.0.1&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.pager.HorizontalPager&#10;import androidx.compose.foundation.pager.rememberPagerState&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.LayoutCoordinates&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.zIndex&#10;import com.hdil.saluschart.core.chart.ChartMark&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartTooltip&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.core.chart.chartDraw.LineStyle&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLine&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLineType&#10;import com.hdil.saluschart.core.chart.chartDraw.YAxisPosition&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartMark&gt;,      // ChartMark 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: Color = ChartColor.Default,&#10;    strokeWidth: Float = 4f,&#10;    minY: Double? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Double? = null,                    // 사용자 지정 최대 Y값&#10;    xLabelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    yAxisPosition: YAxisPosition = YAxisPosition.LEFT,&#10;    interactionType: InteractionType.Line = InteractionType.Line.POINT,&#10;    pointRadius: Pair&lt;Dp, Dp&gt; = Pair(4.dp, 2.dp),&#10;    showLegend: Boolean = false,&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    xLabelAutoSkip: Boolean = true,&#10;    maxXTicksLimit: Int? = null,&#10;    referenceLineType: ReferenceLineType = ReferenceLineType.NONE,&#10;    referenceLineColor: Color = Color.Red,&#10;    referenceLineStrokeWidth: Dp = 2.dp,&#10;    referenceLineStyle: LineStyle = LineStyle.DASHED,&#10;    showReferenceLineLabel: Boolean = false,&#10;    referenceLineLabelFormat: String = &quot;평균: %.0f&quot;,&#10;    referenceLineInteractive: Boolean = false,&#10;    onReferenceLineClick: (() -&gt; Unit)? = null,&#10;    // Display&#10;    showTitle: Boolean = true,&#10;    showYAxis: Boolean = true,&#10;    showPoint: Boolean = false,&#10;    showValue: Boolean = false,&#10;    yTickStep: Double? = null,&#10;    unit: String = &quot;&quot;,&#10;    // Scroll/Page&#10;    windowSize: Int? = null,&#10;    contentPadding: PaddingValues = PaddingValues(16.dp),&#10;    pageSize: Int? = null,&#10;    unifyYAxisAcrossPages: Boolean = true,&#10;    initialPageIndex: Int? = null,&#10;    renderTooltipExternally: Boolean = true,&#10;    yAxisFixedWidth: Dp = 0.dp,&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    // Validate that scrolling and paging modes are not both enabled&#10;    require(!(windowSize != null &amp;&amp; pageSize != null)) {&#10;        &quot;Cannot enable both scrolling mode (windowSize) and paging mode (pageSize) simultaneously&quot;&#10;    }&#10;&#10;    // compute effective page size (0 = off)&#10;    val requestedPageSize = (pageSize ?: 0).coerceAtLeast(0)&#10;&#10;    // enable paging if pageSize is provided and data exceeds page size&#10;    val enablePaging = requestedPageSize &gt; 0 &amp;&amp; data.size &gt; requestedPageSize&#10;&#10;    if (enablePaging) {&#10;        LineChartPagedInternal(&#10;            modifier = modifier,&#10;            data = data,&#10;            pageSize = requestedPageSize,&#10;            // visuals&#10;            title = title,&#10;            xLabel = xLabel,&#10;            yLabel = yLabel,&#10;            lineColor = lineColor,&#10;            strokeWidth = strokeWidth,&#10;            xLabelTextSize = xLabelTextSize,&#10;            tooltipTextSize = tooltipTextSize,&#10;            interactionType = interactionType,&#10;            yAxisPosition = yAxisPosition,&#10;            showPoint = showPoint,&#10;            showValue = showValue,&#10;            showYAxis = showYAxis,&#10;            // scale/paging&#10;            showTitle = showTitle,&#10;            outerPadding = contentPadding,&#10;            unifyYAxisAcrossPages = unifyYAxisAcrossPages,&#10;            yTickStep = yTickStep,&#10;            initialPageIndex = initialPageIndex,&#10;            minY = minY,&#10;            maxY = maxY,&#10;            unit = unit,&#10;            yAxisFixedWidth = yAxisFixedWidth,&#10;            maxXTicksLimit = maxXTicksLimit,&#10;            xLabelAutoSkip = xLabelAutoSkip&#10;        )&#10;        return&#10;    }&#10;&#10;    val chartType = ChartType.LINE&#10;    val useScrolling = windowSize != null &amp;&amp; windowSize &lt; data.size&#10;    val isFixedYAxis = showYAxis &amp;&amp; useScrolling&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(modifier = modifier.padding(contentPadding)) {&#10;        if (showTitle) {&#10;            Text(title, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(8.dp))&#10;        }&#10;        BoxWithConstraints {&#10;            val availableWidth = maxWidth&#10;            val marginHorizontal = 16.dp&#10;&#10;            val canvasWidth = if (useScrolling) {&#10;                val chartWidth = availableWidth - (marginHorizontal * 2)&#10;                val sectionsCount = (data.size.toFloat() / windowSize!!.toFloat()).toInt()&#10;                chartWidth * sectionsCount&#10;            } else null&#10;&#10;            val xLabels = data.map { it.label ?: it.x.toString() }&#10;            val yValues = data.map { it.y }&#10;&#10;            var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;            var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;            var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;            var chartPaneCoords by remember { mutableStateOf&lt;LayoutCoordinates?&gt;(null) }&#10;            var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;&#10;            Row(Modifier.fillMaxSize()) {&#10;&#10;                // LEFT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Use 0.dp padding when Y-axis is hidden (external axis handles it) or when it's a fixed axis on that side&#10;                val startPad = if (!showYAxis || (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT)) 0.dp else marginHorizontal&#10;                val endPad = if (!showYAxis || (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT)) 0.dp else marginHorizontal&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .let { if (useScrolling) it.horizontalScroll(scrollState, overscrollEffect = null) else it }&#10;                        .padding(start = startPad, end = endPad)&#10;                        .onGloballyPositioned { chartPaneCoords = it }&#10;                ) {&#10;                    Canvas(&#10;                        modifier = if (useScrolling) {&#10;                            Modifier.width(canvasWidth!!).fillMaxHeight()&#10;                        } else {&#10;                            Modifier.fillMaxSize()&#10;                        }&#10;                    ) {&#10;                        canvasSize = size&#10;                        val metrics = ChartMath.computeMetrics(&#10;                            size = size,&#10;                            values = yValues,&#10;                            chartType = chartType,&#10;                            minY = minY,&#10;                            maxY = maxY,&#10;                            includeYAxisPadding = !isFixedYAxis,  // no inner L/R padding when fixed axis is used&#10;                            fixedTickStep = yTickStep&#10;                        )&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics, yAxisPosition, drawLabels = showYAxis &amp;&amp; !isFixedYAxis)&#10;                        if (showYAxis &amp;&amp; !isFixedYAxis) ChartDraw.drawYAxis(this, metrics, yAxisPosition)&#10;&#10;                        val points = ChartMath.Line.mapLineToCanvasPoints(data, size, metrics)&#10;                        canvasPoints = points&#10;                        ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                        ChartDraw.Line.drawLineXAxisLabels(&#10;                            ctx = drawContext,&#10;                            labels = xLabels,&#10;                            metrics = metrics,&#10;                            textSize = xLabelTextSize,&#10;                            maxXTicksLimit = maxXTicksLimit,&#10;                            xLabelAutoSkip = xLabelAutoSkip&#10;                        )&#10;&#10;                        val canvasForLabels = Size(&#10;                            width  = chartMetrics!!.paddingX + chartMetrics!!.chartWidth,&#10;                            height = chartMetrics!!.chartHeight&#10;                        )&#10;&#10;                        ChartMath.Line.computeLabelAnchors(&#10;                            points = points,&#10;                            values = yValues.map { it.toFloat() },&#10;                            canvas = canvasForLabels,&#10;                            textPx = with(drawContext.density) { 12.sp.toPx() },&#10;                            padPx  = with(drawContext.density) { 2.dp.toPx() },&#10;                            minGapToLinePx = with(drawContext.density) { 6.dp.toPx() },&#10;                            passes = 6,&#10;                            strokeWidthPx = strokeWidth,&#10;                            edgeMarginPx  = with(drawContext.density) { 8.dp.toPx() }&#10;                        )&#10;                    }&#10;&#10;                    // Interactions / points&#10;                    when (interactionType) {&#10;                        InteractionType.Line.TOUCH_AREA -&gt; {&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(yValues.size) { metrics.minY },&#10;                                    maxValues = yValues,&#10;                                    metrics = metrics,&#10;                                    useLineChartPositioning = true,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    isTouchArea = true,&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex&#10;                                )&#10;                            }&#10;&#10;                            // draw points/labels only when we actually know canvas size &amp; have points&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = null,&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = false,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize,&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        InteractionType.Line.POINT -&gt; {&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = { index -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = true,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize               // ← same here&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Reference line&#10;                    if (referenceLineType != ReferenceLineType.NONE) {&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ReferenceLine.ReferenceLine(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                data = data,&#10;                                metrics = metrics,&#10;                                chartType = chartType,&#10;                                referenceLineType = referenceLineType,&#10;                                color = referenceLineColor,&#10;                                strokeWidth = referenceLineStrokeWidth,&#10;                                lineStyle = referenceLineStyle,&#10;                                showLabel = showReferenceLineLabel,&#10;                                labelFormat = referenceLineLabelFormat,&#10;                                yAxisPosition = yAxisPosition,&#10;                                interactive = referenceLineInteractive,&#10;                                onClick = onReferenceLineClick&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // ---- External tooltip overlay (top-most, with clamping) ----&#10;                    if (renderTooltipExternally &amp;&amp;&#10;                        selectedPointIndex != null &amp;&amp;&#10;                        selectedPointIndex in canvasPoints.indices&#10;                    ) {&#10;                        val i = selectedPointIndex!!&#10;                        val pt = canvasPoints[i] // canvas-space point&#10;                        val density = LocalDensity.current&#10;&#10;                        var hostSize by remember { mutableStateOf(IntSize.Zero) }&#10;                        var tipSize  by remember { mutableStateOf(IntSize.Zero) }&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .zIndex(2f)                    // above everything in this Box&#10;                                .onSizeChanged { hostSize = it }&#10;                        ) {&#10;                            val pad = with(density) { 8.dp.toPx() }&#10;&#10;                            // desired position: to the right and above the point&#10;                            val desiredX = pt.x + pad&#10;                            val desiredYAbove = pt.y - pad - tipSize.height&#10;&#10;                            // if there isn't room above, place it below the point&#10;                            val yPlaced = if (desiredYAbove &lt; 0f) (pt.y + pad)&#10;                            else desiredYAbove&#10;&#10;                            // clamp inside the host box on both axes&#10;                            val maxX = (hostSize.width  - tipSize.width ).coerceAtLeast(0)&#10;                            val maxY = (hostSize.height - tipSize.height).coerceAtLeast(0)&#10;                            val xClamped = desiredX.coerceIn(0f, maxX.toFloat())&#10;                            val yClamped = yPlaced.coerceIn(0f, maxY.toFloat())&#10;&#10;                            ChartTooltip(&#10;                                ChartMark = data[i],&#10;                                unit = unit,&#10;                                modifier = Modifier&#10;                                    .offset { IntOffset(xClamped.toInt(), yClamped.toInt()) }&#10;                                    .onSizeChanged { tipSize = it }   // measure so clamping is exact&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // RIGHT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LineChartPagedInternal(&#10;    modifier: Modifier,&#10;    data: List&lt;ChartMark&gt;,&#10;    pageSize: Int,&#10;    // visuals&#10;    title: String,&#10;    xLabel: String,&#10;    yLabel: String,&#10;    lineColor: Color,&#10;    strokeWidth: Float,&#10;    xLabelTextSize: Float,&#10;    tooltipTextSize: Float,&#10;    interactionType: InteractionType.Line,&#10;    yAxisPosition: YAxisPosition,&#10;    showPoint: Boolean,&#10;    showValue: Boolean,&#10;    showYAxis: Boolean,&#10;    // scale/paging&#10;    showTitle: Boolean,&#10;    unifyYAxisAcrossPages: Boolean,&#10;    yTickStep: Double?,&#10;    initialPageIndex: Int?,&#10;    minY: Double?,&#10;    maxY: Double?,&#10;    unit: String,&#10;    outerPadding: PaddingValues = PaddingValues(0.dp),&#10;    yAxisFixedWidth: Dp = 0.dp,&#10;    maxXTicksLimit: Int? = null,&#10;    xLabelAutoSkip: Boolean&#10;) {&#10;    val pageCount = remember(data.size, pageSize) {&#10;        kotlin.math.ceil(data.size / pageSize.toFloat()).toInt()&#10;    }&#10;    val firstPage = initialPageIndex ?: (pageCount - 1).coerceAtLeast(0)&#10;    val pagerState = rememberPagerState(initialPage = firstPage, pageCount = { pageCount })&#10;&#10;    // Compute unified Y-axis range using the lighter function (no pixel calculations)&#10;    val yAxisRange = remember(data, minY, maxY, yTickStep) {&#10;        val yValues = data.map { it.y }&#10;        ChartMath.computeYAxisRange(&#10;            values = yValues,&#10;            chartType = ChartType.LINE,&#10;            minY = minY,&#10;            maxY = maxY,&#10;            fixedTickStep = yTickStep&#10;        )&#10;    }&#10;&#10;    val maxRounded = yAxisRange.maxY&#10;    val effectiveTickStep = yAxisRange.tickStep&#10;&#10;    Column(modifier = modifier.padding(outerPadding)) {&#10;        if (showTitle) {&#10;            Text(title, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(12.dp))&#10;        }&#10;&#10;        Row(Modifier.fillMaxWidth()) {&#10;            // LEFT fixed external Y-axis&#10;            if (showYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = effectiveTickStep.toFloat(),&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;&#10;            // pages area&#10;            HorizontalPager(&#10;                state = pagerState,&#10;                modifier = Modifier.weight(1f)&#10;            ) { page -&gt;&#10;                val start = page * pageSize&#10;                val end = kotlin.math.min(start + pageSize, data.size)&#10;                val slice = data.subList(start, end)&#10;&#10;                // Render a normal LineChart page:&#10;                // - no inner scroll (windowSize = null)&#10;                // - maxY unified with the external axis&#10;                LineChart(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    data = slice,&#10;                    xLabel = xLabel,&#10;                    yLabel = yLabel,&#10;                    title = title,&#10;                    lineColor = lineColor,&#10;                    strokeWidth = strokeWidth,&#10;                    minY = minY,&#10;                    maxY = maxRounded,&#10;                    xLabelTextSize = xLabelTextSize,&#10;                    tooltipTextSize = tooltipTextSize,&#10;                    yAxisPosition = yAxisPosition,&#10;                    interactionType = interactionType,&#10;                    showPoint = showPoint,&#10;                    showValue = showValue,&#10;                    maxXTicksLimit = maxXTicksLimit,&#10;                    xLabelAutoSkip = xLabelAutoSkip,&#10;                    referenceLineType = ReferenceLineType.NONE,&#10;                    showTitle = false,                    // external axis handles it&#10;                    showYAxis = false,                    // external axis handles it&#10;                    yTickStep = effectiveTickStep,        // keep grid aligned with external axis&#10;                    windowSize = null,                    // no inner scroll&#10;                    contentPadding = PaddingValues(&#10;                        start = if (yAxisPosition == YAxisPosition.LEFT) 0.dp else 0.dp,&#10;                        end = if (yAxisPosition == YAxisPosition.RIGHT) 0.dp else 0.dp,&#10;                        top = 0.dp,&#10;                        bottom = 0.dp&#10;                    ),&#10;                    pageSize = null,                      // don't recurse&#10;                    unit = unit&#10;                )&#10;            }&#10;&#10;            // RIGHT fixed external Y-axis&#10;            if (showYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = effectiveTickStep.toFloat(),&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FixedPagerYAxisLine(&#10;    maxY: Double,&#10;    yAxisPosition: YAxisPosition,&#10;    step: Float,&#10;    width: Dp&#10;) {&#10;    Canvas(&#10;        modifier = Modifier&#10;            .width(width)&#10;            .fillMaxHeight()&#10;    ) {&#10;        val m = ChartMath.computeMetrics(&#10;            size = size,&#10;            values = listOf(0.0, maxY.toDouble()),&#10;            chartType = ChartType.LINE,&#10;            minY = 0.0,                    // start at 0 for typical activity charts (tweak if needed)&#10;            maxY = maxY.toDouble(),&#10;            includeYAxisPadding = false,  // no inner side padding; this pane is just the axis&#10;            fixedTickStep = step.toDouble(),&#10;        )&#10;        ChartDraw.drawYAxisStandalone(&#10;            drawScope = this,&#10;            metrics = m,&#10;            yAxisPosition = yAxisPosition,&#10;            paneWidthPx = size.width&#10;        )&#10;    }&#10;}&#10;&#10;// helper so the call site reads clearly; adapt if your Line charts shouldn’t force 0&#10;private fun chartTypeForLineWantsZero(): Boolean = false&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.pager.HorizontalPager&#10;import androidx.compose.foundation.pager.rememberPagerState&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.LayoutCoordinates&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.zIndex&#10;import com.hdil.saluschart.core.chart.ChartMark&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartTooltip&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.core.chart.chartDraw.LineStyle&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLine&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLineType&#10;import com.hdil.saluschart.core.chart.chartDraw.YAxisPosition&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartMark&gt;,      // ChartMark 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: Color = ChartColor.Default,&#10;    strokeWidth: Float = 4f,&#10;    minY: Double? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Double? = null,                    // 사용자 지정 최대 Y값&#10;    xLabelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    yAxisPosition: YAxisPosition = YAxisPosition.LEFT,&#10;    interactionType: InteractionType.Line = InteractionType.Line.POINT,&#10;    pointRadius: Pair&lt;Dp, Dp&gt; = Pair(4.dp, 2.dp),&#10;    showLegend: Boolean = false,&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    xLabelAutoSkip: Boolean = true,&#10;    maxXTicksLimit: Int? = null,&#10;    referenceLineType: ReferenceLineType = ReferenceLineType.NONE,&#10;    referenceLineColor: Color = Color.Red,&#10;    referenceLineStrokeWidth: Dp = 2.dp,&#10;    referenceLineStyle: LineStyle = LineStyle.DASHED,&#10;    showReferenceLineLabel: Boolean = false,&#10;    referenceLineLabelFormat: String = &quot;평균: %.0f&quot;,&#10;    referenceLineInteractive: Boolean = false,&#10;    onReferenceLineClick: (() -&gt; Unit)? = null,&#10;    // Display&#10;    showTitle: Boolean = true,&#10;    showYAxis: Boolean = true,&#10;    showPoint: Boolean = false,&#10;    showValue: Boolean = false,&#10;    yTickStep: Double? = null,&#10;    unit: String = &quot;&quot;,&#10;    // Scroll/Page&#10;    windowSize: Int? = null,&#10;    contentPadding: PaddingValues = PaddingValues(16.dp),&#10;    pageSize: Int? = null,&#10;    unifyYAxisAcrossPages: Boolean = true,&#10;    initialPageIndex: Int? = null,&#10;    renderTooltipExternally: Boolean = true,&#10;    yAxisFixedWidth: Dp = 0.dp,&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    // Validate that scrolling and paging modes are not both enabled&#10;    require(!(windowSize != null &amp;&amp; pageSize != null)) {&#10;        &quot;Cannot enable both scrolling mode (windowSize) and paging mode (pageSize) simultaneously&quot;&#10;    }&#10;&#10;    // compute effective page size (0 = off)&#10;    val requestedPageSize = (pageSize ?: 0).coerceAtLeast(0)&#10;&#10;    // enable paging if pageSize is provided and data exceeds page size&#10;    val enablePaging = requestedPageSize &gt; 0 &amp;&amp; data.size &gt; requestedPageSize&#10;&#10;    if (enablePaging) {&#10;        LineChartPagedInternal(&#10;            modifier = modifier,&#10;            data = data,&#10;            pageSize = requestedPageSize,&#10;            // visuals&#10;            title = title,&#10;            xLabel = xLabel,&#10;            yLabel = yLabel,&#10;            lineColor = lineColor,&#10;            strokeWidth = strokeWidth,&#10;            xLabelTextSize = xLabelTextSize,&#10;            tooltipTextSize = tooltipTextSize,&#10;            interactionType = interactionType,&#10;            yAxisPosition = yAxisPosition,&#10;            showPoint = showPoint,&#10;            showValue = showValue,&#10;            showYAxis = showYAxis,&#10;            // scale/paging&#10;            showTitle = showTitle,&#10;            outerPadding = contentPadding,&#10;            unifyYAxisAcrossPages = unifyYAxisAcrossPages,&#10;            yTickStep = yTickStep,&#10;            initialPageIndex = initialPageIndex,&#10;            minY = minY,&#10;            maxY = maxY,&#10;            unit = unit,&#10;            yAxisFixedWidth = yAxisFixedWidth,&#10;            maxXTicksLimit = maxXTicksLimit,&#10;            xLabelAutoSkip = xLabelAutoSkip&#10;        )&#10;        return&#10;    }&#10;&#10;    val chartType = ChartType.LINE&#10;    val useScrolling = windowSize != null &amp;&amp; windowSize &lt; data.size&#10;    val isFixedYAxis = showYAxis &amp;&amp; useScrolling&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(modifier = modifier.padding(contentPadding)) {&#10;        if (showTitle) {&#10;            Text(title, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(8.dp))&#10;        }&#10;        BoxWithConstraints {&#10;            val availableWidth = maxWidth&#10;            val marginHorizontal = 16.dp&#10;&#10;            val canvasWidth = if (useScrolling) {&#10;                val chartWidth = availableWidth - (marginHorizontal * 2)&#10;                val sectionsCount = (data.size.toFloat() / windowSize!!.toFloat()).toInt()&#10;                chartWidth * sectionsCount&#10;            } else null&#10;&#10;            val xLabels = data.map { it.label ?: it.x.toString() }&#10;            val yValues = data.map { it.y }&#10;&#10;            var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;            var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;            var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;            var chartPaneCoords by remember { mutableStateOf&lt;LayoutCoordinates?&gt;(null) }&#10;            var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;&#10;            Row(Modifier.fillMaxSize()) {&#10;&#10;                // LEFT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Use 0.dp padding when Y-axis is hidden (external axis handles it) or when it's a fixed axis on that side&#10;                val startPad = if (!showYAxis || (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT)) 0.dp else marginHorizontal&#10;                val endPad = if (!showYAxis || (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT)) 0.dp else marginHorizontal&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .let { if (useScrolling) it.horizontalScroll(scrollState, overscrollEffect = null) else it }&#10;                        .padding(start = startPad, end = endPad)&#10;                        .onGloballyPositioned { chartPaneCoords = it }&#10;                ) {&#10;                    Canvas(&#10;                        modifier = if (useScrolling) {&#10;                            Modifier.width(canvasWidth!!).fillMaxHeight()&#10;                        } else {&#10;                            Modifier.fillMaxSize()&#10;                        }&#10;                    ) {&#10;                        canvasSize = size&#10;                        val metrics = ChartMath.computeMetrics(&#10;                            size = size,&#10;                            values = yValues,&#10;                            chartType = chartType,&#10;                            minY = minY,&#10;                            maxY = maxY,&#10;                            includeYAxisPadding = !isFixedYAxis,  // no inner L/R padding when fixed axis is used&#10;                            fixedTickStep = yTickStep&#10;                        )&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics, yAxisPosition, drawLabels = showYAxis &amp;&amp; !isFixedYAxis)&#10;                        if (showYAxis &amp;&amp; !isFixedYAxis) ChartDraw.drawYAxis(this, metrics, yAxisPosition)&#10;&#10;                        val points = ChartMath.Line.mapLineToCanvasPoints(data, size, metrics)&#10;                        canvasPoints = points&#10;                        ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                        ChartDraw.Line.drawLineXAxisLabels(&#10;                            ctx = drawContext,&#10;                            labels = xLabels,&#10;                            metrics = metrics,&#10;                            textSize = xLabelTextSize,&#10;                            maxXTicksLimit = maxXTicksLimit,&#10;                            xLabelAutoSkip = xLabelAutoSkip&#10;                        )&#10;&#10;                        val canvasForLabels = Size(&#10;                            width  = chartMetrics!!.paddingX + chartMetrics!!.chartWidth,&#10;                            height = chartMetrics!!.chartHeight&#10;                        )&#10;&#10;                        ChartMath.Line.computeLabelAnchors(&#10;                            points = points,&#10;                            values = yValues.map { it.toFloat() },&#10;                            canvas = canvasForLabels,&#10;                            textPx = with(drawContext.density) { 12.sp.toPx() },&#10;                            padPx  = with(drawContext.density) { 2.dp.toPx() },&#10;                            minGapToLinePx = with(drawContext.density) { 6.dp.toPx() },&#10;                            passes = 6,&#10;                            strokeWidthPx = strokeWidth,&#10;                            edgeMarginPx  = with(drawContext.density) { 8.dp.toPx() }&#10;                        )&#10;                    }&#10;&#10;                    // Interactions / points&#10;                    when (interactionType) {&#10;                        InteractionType.Line.TOUCH_AREA -&gt; {&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(yValues.size) { metrics.minY },&#10;                                    maxValues = yValues,&#10;                                    metrics = metrics,&#10;                                    useLineChartPositioning = true,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    isTouchArea = true,&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex&#10;                                )&#10;                            }&#10;&#10;                            // draw points/labels only when we actually know canvas size &amp; have points&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = null,&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = false,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize,&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        InteractionType.Line.POINT -&gt; {&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = { index -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = true,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize               // ← same here&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Reference line&#10;                    if (referenceLineType != ReferenceLineType.NONE) {&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ReferenceLine.ReferenceLine(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                data = data,&#10;                                metrics = metrics,&#10;                                chartType = chartType,&#10;                                referenceLineType = referenceLineType,&#10;                                color = referenceLineColor,&#10;                                strokeWidth = referenceLineStrokeWidth,&#10;                                lineStyle = referenceLineStyle,&#10;                                showLabel = showReferenceLineLabel,&#10;                                labelFormat = referenceLineLabelFormat,&#10;                                yAxisPosition = yAxisPosition,&#10;                                interactive = referenceLineInteractive,&#10;                                onClick = onReferenceLineClick&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // ---- External tooltip overlay (top-most, with clamping) ----&#10;                    if (renderTooltipExternally &amp;&amp;&#10;                        selectedPointIndex != null &amp;&amp;&#10;                        selectedPointIndex in canvasPoints.indices&#10;                    ) {&#10;                        val i = selectedPointIndex!!&#10;                        val pt = canvasPoints[i] // canvas-space point&#10;                        val density = LocalDensity.current&#10;&#10;                        var hostSize by remember { mutableStateOf(IntSize.Zero) }&#10;                        var tipSize  by remember { mutableStateOf(IntSize.Zero) }&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .zIndex(2f)                    // above everything in this Box&#10;                                .onSizeChanged { hostSize = it }&#10;                        ) {&#10;                            val pad = with(density) { 8.dp.toPx() }&#10;&#10;                            // desired position: to the right and above the point&#10;                            val desiredX = pt.x + pad&#10;                            val desiredYAbove = pt.y - pad - tipSize.height&#10;&#10;                            // if there isn't room above, place it below the point&#10;                            val yPlaced = if (desiredYAbove &lt; 0f) (pt.y + pad)&#10;                            else desiredYAbove&#10;&#10;                            // clamp inside the host box on both axes&#10;                            val maxX = (hostSize.width  - tipSize.width ).coerceAtLeast(0)&#10;                            val maxY = (hostSize.height - tipSize.height).coerceAtLeast(0)&#10;                            val xClamped = desiredX.coerceIn(0f, maxX.toFloat())&#10;                            val yClamped = yPlaced.coerceIn(0f, maxY.toFloat())&#10;&#10;                            ChartTooltip(&#10;                                ChartMark = data[i],&#10;                                unit = unit,&#10;                                modifier = Modifier&#10;                                    .offset { IntOffset(xClamped.toInt(), yClamped.toInt()) }&#10;                                    .onSizeChanged { tipSize = it }   // measure so clamping is exact&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // RIGHT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LineChartPagedInternal(&#10;    modifier: Modifier,&#10;    data: List&lt;ChartMark&gt;,&#10;    pageSize: Int,&#10;    // visuals&#10;    title: String,&#10;    xLabel: String,&#10;    yLabel: String,&#10;    lineColor: Color,&#10;    strokeWidth: Float,&#10;    xLabelTextSize: Float,&#10;    tooltipTextSize: Float,&#10;    interactionType: InteractionType.Line,&#10;    yAxisPosition: YAxisPosition,&#10;    showPoint: Boolean,&#10;    showValue: Boolean,&#10;    showYAxis: Boolean,&#10;    // scale/paging&#10;    showTitle: Boolean,&#10;    unifyYAxisAcrossPages: Boolean,&#10;    yTickStep: Double?,&#10;    initialPageIndex: Int?,&#10;    minY: Double?,&#10;    maxY: Double?,&#10;    unit: String,&#10;    outerPadding: PaddingValues = PaddingValues(0.dp),&#10;    yAxisFixedWidth: Dp = 0.dp,&#10;    maxXTicksLimit: Int? = null,&#10;    xLabelAutoSkip: Boolean&#10;) {&#10;    val pageCount = remember(data.size, pageSize) {&#10;        kotlin.math.ceil(data.size / pageSize.toFloat()).toInt()&#10;    }&#10;    val firstPage = initialPageIndex ?: (pageCount - 1).coerceAtLeast(0)&#10;    val pagerState = rememberPagerState(initialPage = firstPage, pageCount = { pageCount })&#10;&#10;    // Compute unified Y-axis range using the lighter function (no pixel calculations)&#10;    val yAxisRange = remember(data, minY, maxY, yTickStep) {&#10;        val yValues = data.map { it.y }&#10;        ChartMath.computeYAxisRange(&#10;            values = yValues,&#10;            chartType = ChartType.LINE,&#10;            minY = minY,&#10;            maxY = maxY,&#10;            fixedTickStep = yTickStep&#10;        )&#10;    }&#10;&#10;    val maxRounded = yAxisRange.maxY&#10;    val effectiveTickStep = yAxisRange.tickStep&#10;&#10;    Column(modifier = modifier.padding(outerPadding)) {&#10;        if (showTitle) {&#10;            Text(title, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(12.dp))&#10;        }&#10;&#10;        Row(Modifier.fillMaxWidth()) {&#10;            // LEFT fixed external Y-axis&#10;            if (showYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = effectiveTickStep.toFloat(),&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;&#10;            // pages area&#10;            HorizontalPager(&#10;                state = pagerState,&#10;                modifier = Modifier.weight(1f)&#10;            ) { page -&gt;&#10;                val start = page * pageSize&#10;                val end = kotlin.math.min(start + pageSize, data.size)&#10;                val slice = data.subList(start, end)&#10;&#10;                // Render a normal LineChart page:&#10;                // - no inner scroll (windowSize = null)&#10;                // - maxY unified with the external axis&#10;                LineChart(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    data = slice,&#10;                    xLabel = xLabel,&#10;                    yLabel = yLabel,&#10;                    title = title,&#10;                    lineColor = lineColor,&#10;                    strokeWidth = strokeWidth,&#10;                    minY = minY,&#10;                    maxY = maxRounded,&#10;                    xLabelTextSize = xLabelTextSize,&#10;                    tooltipTextSize = tooltipTextSize,&#10;                    yAxisPosition = yAxisPosition,&#10;                    interactionType = interactionType,&#10;                    showPoint = showPoint,&#10;                    showValue = showValue,&#10;                    maxXTicksLimit = maxXTicksLimit,&#10;                    xLabelAutoSkip = xLabelAutoSkip,&#10;                    referenceLineType = ReferenceLineType.NONE,&#10;                    showTitle = false,                    // external axis handles it&#10;                    showYAxis = false,                    // external axis handles it&#10;                    yTickStep = effectiveTickStep,        // keep grid aligned with external axis&#10;                    windowSize = null,                    // no inner scroll&#10;                    contentPadding = PaddingValues(&#10;                        start = if (yAxisPosition == YAxisPosition.LEFT) 0.dp else 0.dp,&#10;                        end = if (yAxisPosition == YAxisPosition.RIGHT) 0.dp else 0.dp,&#10;                        top = 0.dp,&#10;                        bottom = 0.dp&#10;                    ),&#10;                    pageSize = null,                      // don't recurse&#10;                    unit = unit&#10;                )&#10;            }&#10;&#10;            // RIGHT fixed external Y-axis&#10;            if (showYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = effectiveTickStep.toFloat(),&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FixedPagerYAxisLine(&#10;    maxY: Double,&#10;    yAxisPosition: YAxisPosition,&#10;    step: Float,&#10;    width: Dp&#10;) {&#10;    Canvas(&#10;        modifier = Modifier&#10;            .width(width)&#10;            .fillMaxHeight()&#10;    ) {&#10;        val m = ChartMath.computeMetrics(&#10;            size = size,&#10;            values = listOf(0.0, maxY.toDouble()),&#10;            chartType = ChartType.LINE,&#10;            minY = 0.0,                    // start at 0 for typical activity charts (tweak if needed)&#10;            maxY = maxY.toDouble(),&#10;            includeYAxisPadding = false,  // no inner side padding; this pane is just the axis&#10;            fixedTickStep = step.toDouble(),&#10;        )&#10;        ChartDraw.drawYAxisStandalone(&#10;            drawScope = this,&#10;            metrics = m,&#10;            yAxisPosition = yAxisPosition,&#10;            paneWidthPx = size.width&#10;        )&#10;    }&#10;}&#10;&#10;// helper so the call site reads clearly; adapt if your Line charts shouldn’t force 0&#10;private fun chartTypeForLineWantsZero(): Boolean = false" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>