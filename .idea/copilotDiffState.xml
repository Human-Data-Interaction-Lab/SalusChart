<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/transform/src/main/java/com/hdil/saluschart/core/transform/TimeDataPoint.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/transform/src/main/java/com/hdil/saluschart/core/transform/TimeDataPoint.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.transform&#10;&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.util.AggregationType&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.time.ZoneId&#10;import java.time.temporal.TemporalAdjusters&#10;import java.time.DayOfWeek&#10;&#10;&#10;/**&#10; * 시간 기반 원시 데이터 포인트&#10; * ChartPoint로 변환해서 사용&#10; * @param x 시간 데이터 (Instant 타입)&#10; * @param y 측정값 리스트 (단일 값용)&#10; * @param yMultiple 다중 측정값 맵 (다중 값용) - 키는 속성명, 값은 해당 속성의 값 리스트&#10; * @param timeUnit 시간 단위&#10; */&#10;data class TimeDataPoint(&#10;    val x : List&lt;Instant&gt;,&#10;    val y : List&lt;Float&gt;? = null,&#10;    val yMultiple : Map&lt;String, List&lt;Float&gt;&gt;? = null,&#10;    val timeUnit : TimeUnitGroup = TimeUnitGroup.HOUR&#10;) {&#10;    init {&#10;        require((y != null) xor (yMultiple != null)) {&#10;            &quot;Either y or yMultiple must be provided, but not both&quot;&#10;        }&#10;        &#10;        if (y != null) {&#10;            require(x.size == y.size) {&#10;                &quot;x and y lists must have the same size&quot;&#10;            }&#10;        }&#10;        &#10;        if (yMultiple != null) {&#10;            require(yMultiple.isNotEmpty()) {&#10;                &quot;yMultiple cannot be empty&quot;&#10;            }&#10;            yMultiple.values.forEach { valueList -&gt;&#10;                require(x.size == valueList.size) {&#10;                    &quot;All value lists in yMultiple must have the same size as x&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    val isSingleValue: Boolean get() = y != null     // 단일 값 여부 확인&#10;    val isMultiValue: Boolean get() = yMultiple != null    // 다중 값 여부 확인&#10;    fun getValues(property: String): List&lt;Float&gt;? = yMultiple?.get(property)    // 다중 값에서 특정 속성의 값 가져오기&#10;    val propertyNames: Set&lt;String&gt; get() = yMultiple?.keys ?: emptySet()    // 다중 값의 속성명 목록 가져오기&#10;}&#10;&#10;/**&#10; * TimeDataPoint를 ChartPoint 리스트로 변환하는 확장 함수&#10; * 단일 값 데이터용&#10; *&#10; * @return ChartPoint 리스트&#10; *&#10; * 각 시간 단위에 따라 레이블이 생성됩니다:&#10; * HOUR: &quot;14시&quot; (for 2 PM)&#10; * DAY: &quot;5/8 월&quot; (for May 8th Monday, includes day of week)&#10; * WEEK: &quot;5월 1주차&quot; (for first week of May)&#10; * MONTH: &quot;2025년 5월&quot; (for May 2025)&#10; * YEAR: &quot;2025년&quot; (for year 2025)&#10; */&#10;fun TimeDataPoint.toChartPoints(): List&lt;ChartPoint&gt; {&#10;    require(isSingleValue) { &quot;Use toChartPointsByProperty() for multi-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = y!![index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint에서 특정 속성을 추출하여 ChartPoint 리스트로 변환하는 확장 함수&#10; *&#10; * @param property 추출할 속성명 (예: &quot;systolic&quot;, &quot;diastolic&quot;, &quot;calories&quot;, &quot;protein&quot; 등)&#10; * @return 해당 속성의 ChartPoint 리스트&#10; */&#10;fun TimeDataPoint.toChartPointsByProperty(property: String): List&lt;ChartPoint&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    require(propertyNames.contains(property)) { &#10;        &quot;Property '$property' not found. Available properties: ${propertyNames.joinToString()}&quot; &#10;    }&#10;    &#10;    val values = getValues(property)!!&#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = values[index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint를 모든 속성별로 분리된 ChartPoint 맵으로 변환하는 확장 함수&#10; *&#10; * @return 속성명을 키로 하고 해당 속성의 ChartPoint 리스트를 값으로 하는 맵&#10; */&#10;fun TimeDataPoint.toChartPointsMap(): Map&lt;String, List&lt;ChartPoint&gt;&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;    &#10;    return propertyNames.associateWith { property -&gt;&#10;        val values = getValues(property)!!&#10;        x.indices.map { index -&gt;&#10;            ChartPoint(&#10;                x = index.toFloat(),&#10;                y = values[index],&#10;                label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 시간 단위에 따른 레이블 생성 (공통 로직)&#10; */&#10;private fun TimeDataPoint.generateTimeLabels(): List&lt;String&gt; {&#10;    return when (timeUnit) {&#10;        TimeUnitGroup.MINUTE -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}:${dateTime.minute.toString().padStart(2, '0')}&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.HOUR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}시&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.DAY -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val dayOfWeekKorean = when (dateTime.dayOfWeek.value) {&#10;                    1 -&gt; &quot;월&quot;&#10;                    2 -&gt; &quot;화&quot;&#10;                    3 -&gt; &quot;수&quot;&#10;                    4 -&gt; &quot;목&quot;&#10;                    5 -&gt; &quot;금&quot;&#10;                    6 -&gt; &quot;토&quot;&#10;                    7 -&gt; &quot;일&quot;&#10;                    else -&gt; &quot;?&quot;&#10;                }&#10;                &quot;${dateTime.monthValue}/${dateTime.dayOfMonth} $dayOfWeekKorean&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.WEEK -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val sunday = dateTime.toLocalDate().with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY))&#10;                val firstSundayOfMonth = LocalDate.of(sunday.year, sunday.month, 1)&#10;                    .let { firstDay -&gt;&#10;                        val dayOfWeek = firstDay.dayOfWeek.value&#10;                        if (dayOfWeek == 7) firstDay else firstDay.plusDays((7 - dayOfWeek).toLong())&#10;                    }&#10;                val weekNumber = ((sunday.toEpochDay() - firstSundayOfMonth.toEpochDay()) / 7 + 1).toInt()&#10;                &quot;${sunday.monthValue}월 ${weekNumber}주차&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.MONTH -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년 ${dateTime.monthValue}월&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.YEAR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년&quot;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.transform&#10;&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.util.AggregationType&#10;import java.time.Instant&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.time.ZoneId&#10;import java.time.temporal.TemporalAdjusters&#10;import java.time.DayOfWeek&#10;&#10;&#10;/**&#10; * 시간 기반 원시 데이터 포인트&#10; * ChartPoint로 변환해서 사용&#10; * @param x 시간 데이터 (Instant 타입)&#10; * @param y 측정값 리스트 (단일 값용)&#10; * @param yMultiple 다중 측정값 맵 (다중 값용) - 키는 속성명, 값은 해당 속성의 값 리스트&#10; * @param timeUnit 시간 단위&#10; */&#10;data class TimeDataPoint(&#10;    val x : List&lt;Instant&gt;,&#10;    val y : List&lt;Float&gt;? = null,&#10;    val yMultiple : Map&lt;String, List&lt;Float&gt;&gt;? = null,&#10;    val timeUnit : TimeUnitGroup = TimeUnitGroup.HOUR&#10;) {&#10;    init {&#10;        require((y != null) xor (yMultiple != null)) {&#10;            &quot;Either y or yMultiple must be provided, but not both&quot;&#10;        }&#10;        &#10;        if (y != null) {&#10;            require(x.size == y.size) {&#10;                &quot;x and y lists must have the same size&quot;&#10;            }&#10;        }&#10;        &#10;        if (yMultiple != null) {&#10;            require(yMultiple.isNotEmpty()) {&#10;                &quot;yMultiple cannot be empty&quot;&#10;            }&#10;            yMultiple.values.forEach { valueList -&gt;&#10;                require(x.size == valueList.size) {&#10;                    &quot;All value lists in yMultiple must have the same size as x&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    val isSingleValue: Boolean get() = y != null     // 단일 값 여부 확인&#10;    val isMultiValue: Boolean get() = yMultiple != null    // 다중 값 여부 확인&#10;    fun getValues(property: String): List&lt;Float&gt;? = yMultiple?.get(property)    // 다중 값에서 특정 속성의 값 가져오기&#10;    val propertyNames: Set&lt;String&gt; get() = yMultiple?.keys ?: emptySet()    // 다중 값의 속성명 목록 가져오기&#10;}&#10;&#10;/**&#10; * TimeDataPoint를 ChartPoint 리스트로 변환하는 확장 함수&#10; * 단일 값 데이터용&#10; *&#10; * @return ChartPoint 리스트&#10; *&#10; * 각 시간 단위에 따라 레이블이 생성됩니다:&#10; * HOUR: &quot;14시&quot; (for 2 PM)&#10; * DAY: &quot;5/8 월&quot; (for May 8th Monday, includes day of week)&#10; * WEEK: &quot;5월 1주차&quot; (for first week of May)&#10; * MONTH: &quot;2025년 5월&quot; (for May 2025)&#10; * YEAR: &quot;2025년&quot; (for year 2025)&#10; */&#10;fun TimeDataPoint.toChartPoints(): List&lt;ChartPoint&gt; {&#10;    require(isSingleValue) { &quot;Use toChartPointsByProperty() for multi-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = y!![index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint에서 특정 속성을 추출하여 ChartPoint 리스트로 변환하는 확장 함수&#10; *&#10; * @param property 추출할 속성명 (예: &quot;systolic&quot;, &quot;diastolic&quot;, &quot;calories&quot;, &quot;protein&quot; 등)&#10; * @return 해당 속성의 ChartPoint 리스트&#10; */&#10;fun TimeDataPoint.toChartPointsByProperty(property: String): List&lt;ChartPoint&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    require(propertyNames.contains(property)) { &#10;        &quot;Property '$property' not found. Available properties: ${propertyNames.joinToString()}&quot; &#10;    }&#10;    &#10;    val values = getValues(property)!!&#10;    val labels = generateTimeLabels()&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = values[index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 다중 값 TimeDataPoint를 모든 속성별로 분리된 ChartPoint 맵으로 변환하는 확장 함수&#10; *&#10; * @return 속성명을 키로 하고 해당 속성의 ChartPoint 리스트를 값으로 하는 맵&#10; */&#10;fun TimeDataPoint.toChartPointsMap(): Map&lt;String, List&lt;ChartPoint&gt;&gt; {&#10;    require(isMultiValue) { &quot;Use toChartPoints() for single-value TimeDataPoint&quot; }&#10;    &#10;    val labels = generateTimeLabels()&#10;    &#10;    return propertyNames.associateWith { property -&gt;&#10;        val values = getValues(property)!!&#10;        x.indices.map { index -&gt;&#10;            ChartPoint(&#10;                x = index.toFloat(),&#10;                y = values[index],&#10;                label = labels.getOrNull(index) ?: x.getOrNull(index)?.toString()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 시간 단위에 따른 레이블 생성 (공통 로직)&#10; */&#10;private fun TimeDataPoint.generateTimeLabels(): List&lt;String&gt; {&#10;    return when (timeUnit) {&#10;        TimeUnitGroup.MINUTE -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}:${dateTime.minute.toString().padStart(2, '0')}&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.HOUR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.hour}시&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.DAY -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val dayOfWeekKorean = when (dateTime.dayOfWeek.value) {&#10;                    1 -&gt; &quot;월&quot;&#10;                    2 -&gt; &quot;화&quot;&#10;                    3 -&gt; &quot;수&quot;&#10;                    4 -&gt; &quot;목&quot;&#10;                    5 -&gt; &quot;금&quot;&#10;                    6 -&gt; &quot;토&quot;&#10;                    7 -&gt; &quot;일&quot;&#10;                    else -&gt; &quot;?&quot;&#10;                }&#10;                &quot;${dateTime.monthValue}/${dateTime.dayOfMonth} $dayOfWeekKorean&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.WEEK -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                val sunday = dateTime.toLocalDate().with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY))&#10;                val firstSundayOfMonth = LocalDate.of(sunday.year, sunday.month, 1)&#10;                    .let { firstDay -&gt;&#10;                        val dayOfWeek = firstDay.dayOfWeek.value&#10;                        if (dayOfWeek == 7) firstDay else firstDay.plusDays((7 - dayOfWeek).toLong())&#10;                    }&#10;                val weekNumber = ((sunday.toEpochDay() - firstSundayOfMonth.toEpochDay()) / 7 + 1).toInt()&#10;                &quot;${sunday.monthValue}월 ${weekNumber}주차&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.MONTH -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년 ${dateTime.monthValue}월&quot;&#10;            }&#10;        }&#10;        TimeUnitGroup.YEAR -&gt; {&#10;            x.map { instant -&gt;&#10;                val dateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())&#10;                &quot;${dateTime.year}년&quot;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.pager.HorizontalPager&#10;import androidx.compose.foundation.pager.rememberPagerState&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.LayoutCoordinates&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.zIndex&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartTooltip&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.core.chart.chartDraw.LineStyle&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLine&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLineType&#10;import com.hdil.saluschart.core.chart.chartDraw.YAxisPosition&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: Color = ChartColor.Default,&#10;    strokeWidth: Float = 4f,&#10;    minY: Float? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Float? = null,                    // 사용자 지정 최대 Y값&#10;    xLabelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    yAxisPosition: YAxisPosition = YAxisPosition.LEFT,  // Y축 위치&#10;    interactionType: InteractionType.Line = InteractionType.Line.POINT,&#10;    showPoint: Boolean = false, // 포인트 표시 여부&#10;    pointRadius: Pair&lt;Dp, Dp&gt; = Pair(4.dp, 2.dp), // 포인트 외부 반지름, 내부 반지름&#10;    showValue: Boolean = false, // 값 표시 여부&#10;    showLegend: Boolean = false,&#10;    windowSize: Int? = null, // 윈도우 크기 (null이면 전체 화면)&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    chartType : ChartType = ChartType.LINE, // 차트 타입 (툴팁 위치 결정용&#10;    maxXTicksLimit: Int? = null,             // X축에 표시할 최대 라벨 개수 (null이면 모든 라벨 표시)&#10;    referenceLineType: ReferenceLineType = ReferenceLineType.NONE,&#10;    referenceLineColor: Color = Color.Red,&#10;    referenceLineStrokeWidth: Dp = 2.dp,&#10;    referenceLineStyle: LineStyle = LineStyle.DASHED,&#10;    showReferenceLineLabel: Boolean = false,&#10;    referenceLineLabelFormat: String = &quot;평균: %.0f&quot;,&#10;    referenceLineInteractive: Boolean = false,&#10;    onReferenceLineClick: (() -&gt; Unit)? = null,&#10;&#10;    // fixed external Y-axis support&#10;    fixedYAxis: Boolean = false,&#10;    yAxisFixedWidth: Dp = 56.dp,&#10;    yTickStep: Float? = null,                    // e.g., 10f for even ticks&#10;    contentPadding: PaddingValues = PaddingValues(16.dp),&#10;    showTitle: Boolean = true,&#10;    autoFixYAxisOnScroll: Boolean = true,         // auto-fix when horizontally scrollable&#10;&#10;    pagingEnabled: Boolean = false,  // when true: use page-based swipe instead of free scroll&#10;    pageSize: Int = 0,               // items per page (e.g., 7 for a week)&#10;    unifyYAxisAcrossPages: Boolean = true,&#10;    initialPage: Int? = null,&#10;&#10;    renderTooltipExternally: Boolean = true,&#10;    unit: String = &quot;&quot;, // Added unit parameter for tooltip&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    if (pagingEnabled &amp;&amp; pageSize &gt; 0 &amp;&amp; data.size &gt; pageSize) {&#10;        LineChartPagedInternal(&#10;            modifier = modifier,&#10;            data = data,&#10;            pageSize = pageSize,&#10;            // carry over visual options&#10;            title = title,&#10;            xLabel = xLabel,&#10;            yLabel = yLabel,&#10;            lineColor = lineColor,&#10;            strokeWidth = strokeWidth,&#10;            xLabelTextSize = xLabelTextSize,&#10;            tooltipTextSize = tooltipTextSize,&#10;            interactionType = interactionType,&#10;            yAxisPosition = yAxisPosition,&#10;            yAxisFixedWidth = yAxisFixedWidth,      // external axis width&#10;            showPoint = showPoint,&#10;            showValue = showValue,&#10;            onReferenceLineClick = onReferenceLineClick,&#10;            // scale/paging options&#10;            unifyYAxisAcrossPages = unifyYAxisAcrossPages,&#10;            yTickStep = yTickStep,&#10;            initialPage = initialPage,&#10;            // we want fixed axis + no inner scroll on each page&#10;            minY = minY,&#10;            maxY = maxY&#10;        )&#10;        return&#10;    }&#10;&#10;    // windowSize 기반 스크롤 여부 결정&#10;    val useScrolling = windowSize != null &amp;&amp; windowSize &lt; data.size&#10;    val isFixedYAxis = if (autoFixYAxisOnScroll) (fixedYAxis || useScrolling) else fixedYAxis&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(modifier = modifier.padding(contentPadding)) {&#10;        if (showTitle) {&#10;            Text(title, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(8.dp))&#10;        }&#10;        BoxWithConstraints {&#10;            val availableWidth = maxWidth&#10;            val marginHorizontal = 16.dp&#10;&#10;            val axisGutter = if (isFixedYAxis) 2.dp else 0.dp&#10;&#10;            // paddings for the chart area (axis side gets the small gutter)&#10;            val startPad =&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT) axisGutter else marginHorizontal&#10;            val endPad =&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT) axisGutter else marginHorizontal&#10;&#10;            // width taken by the fixed Y-axis pane (left or right)&#10;            val fixedPaneWidth = if (isFixedYAxis) yAxisFixedWidth else 0.dp&#10;&#10;            // width available to the scrollable chart area (exclude axis pane + inner paddings)&#10;            val contentWidth = availableWidth - fixedPaneWidth - (startPad + endPad)&#10;&#10;            // in scroll mode, canvas spans per-window width * data size&#10;            val canvasWidth = if (useScrolling) {&#10;                val chartWidth = availableWidth - (marginHorizontal * 2)&#10;                val sectionsCount = (data.size.toFloat() / windowSize!!.toFloat()).toInt()&#10;                chartWidth * sectionsCount&#10;            } else null&#10;&#10;            val xLabels = data.map { it.label ?: it.x.toString() }&#10;            val yValues = data.map { it.y }&#10;&#10;            var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;            var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;            var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;            var chartPaneCoords by remember { mutableStateOf&lt;LayoutCoordinates?&gt;(null) }&#10;            var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;&#10;            Row(Modifier.fillMaxSize()) {&#10;&#10;                // LEFT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .let { if (useScrolling) it.horizontalScroll(scrollState, overscrollEffect = null) else it }&#10;                        .padding(start = startPad, end = endPad)&#10;                        .onGloballyPositioned { chartPaneCoords = it }&#10;                ) {&#10;                    Canvas(&#10;                        modifier = if (useScrolling) {&#10;                            Modifier.width(canvasWidth!!).fillMaxHeight()&#10;                        } else {&#10;                            Modifier.fillMaxSize()&#10;                        }&#10;                    ) {&#10;                        canvasSize = size&#10;                        val metrics = ChartMath.computeMetrics(&#10;                            size = size,&#10;                            values = yValues,&#10;                            chartType = ChartType.LINE,&#10;                            minY = minY,&#10;                            maxY = maxY,&#10;                            includeYAxisPadding = !isFixedYAxis,  // no inner L/R padding when fixed axis is used&#10;                            fixedTickStep = yTickStep&#10;                        )&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics, yAxisPosition, drawLabels = !isFixedYAxis)&#10;                        if (!isFixedYAxis) ChartDraw.drawYAxis(this, metrics, yAxisPosition)&#10;&#10;                        val points = ChartMath.Line.mapLineToCanvasPoints(data, size, metrics)&#10;                        canvasPoints = points&#10;                        ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                        ChartDraw.Line.drawXAxisLabels(&#10;                            ctx = drawContext,&#10;                            labels = xLabels,&#10;                            metrics = metrics,&#10;                            textSize = xLabelTextSize,&#10;                            maxXTicksLimit = maxXTicksLimit&#10;                        )&#10;&#10;                        val canvasForLabels = Size(&#10;                            width  = chartMetrics!!.paddingX + chartMetrics!!.chartWidth,&#10;                            height = chartMetrics!!.chartHeight&#10;                        )&#10;&#10;                        ChartMath.Line.computeLabelAnchors(&#10;                            points = points,&#10;                            values = yValues,&#10;                            canvas = canvasForLabels,&#10;                            textPx = with(drawContext.density) { 12.sp.toPx() },&#10;                            padPx  = with(drawContext.density) { 2.dp.toPx() },&#10;                            minGapToLinePx = with(drawContext.density) { 6.dp.toPx() },&#10;                            passes = 6,&#10;                            strokeWidthPx = strokeWidth,&#10;                            edgeMarginPx  = with(drawContext.density) { 8.dp.toPx() }&#10;                        )&#10;                    }&#10;&#10;                    // Interactions / points&#10;                    when (interactionType) {&#10;                        InteractionType.Line.TOUCH_AREA -&gt; {&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(yValues.size) { metrics.minY },&#10;                                    maxValues = yValues,&#10;                                    metrics = metrics,&#10;                                    useLineChartPositioning = true,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    isTouchArea = true,&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex&#10;                                )&#10;                            }&#10;&#10;                            // draw points/labels only when we actually know canvas size &amp; have points&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = null,&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = false,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize,&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        InteractionType.Line.POINT -&gt; {&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = { index -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = true,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize               // ← same here&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Reference line&#10;                    if (referenceLineType != ReferenceLineType.NONE) {&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ReferenceLine.ReferenceLine(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                data = data,&#10;                                metrics = metrics,&#10;                                chartType = chartType,&#10;                                referenceLineType = referenceLineType,&#10;                                color = referenceLineColor,&#10;                                strokeWidth = referenceLineStrokeWidth,&#10;                                lineStyle = referenceLineStyle,&#10;                                showLabel = showReferenceLineLabel,&#10;                                labelFormat = referenceLineLabelFormat,&#10;                                yAxisPosition = yAxisPosition,&#10;                                interactive = referenceLineInteractive,&#10;                                onClick = onReferenceLineClick&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // ---- External tooltip overlay (top-most, with clamping) ----&#10;                    if (renderTooltipExternally &amp;&amp;&#10;                        selectedPointIndex != null &amp;&amp;&#10;                        selectedPointIndex in canvasPoints.indices&#10;                    ) {&#10;                        val i = selectedPointIndex!!&#10;                        val pt = canvasPoints[i] // canvas-space point&#10;                        val density = LocalDensity.current&#10;&#10;                        var hostSize by remember { mutableStateOf(IntSize.Zero) }&#10;                        var tipSize  by remember { mutableStateOf(IntSize.Zero) }&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .zIndex(2f)                    // above everything in this Box&#10;                                .onSizeChanged { hostSize = it }&#10;                        ) {&#10;                            val pad = with(density) { 8.dp.toPx() }&#10;&#10;                            // desired position: to the right and above the point&#10;                            val desiredX = pt.x + pad&#10;                            val desiredYAbove = pt.y - pad - tipSize.height&#10;&#10;                            // if there isn't room above, place it below the point&#10;                            val yPlaced = if (desiredYAbove &lt; 0f) (pt.y + pad)&#10;                            else desiredYAbove&#10;&#10;                            // clamp inside the host box on both axes&#10;                            val maxX = (hostSize.width  - tipSize.width ).coerceAtLeast(0)&#10;                            val maxY = (hostSize.height - tipSize.height).coerceAtLeast(0)&#10;                            val xClamped = desiredX.coerceIn(0f, maxX.toFloat())&#10;                            val yClamped = yPlaced.coerceIn(0f, maxY.toFloat())&#10;&#10;                            ChartTooltip(&#10;                                chartPoint = data[i],&#10;                                unit = unit,&#10;                                modifier = Modifier&#10;                                    .offset { IntOffset(xClamped.toInt(), yClamped.toInt()) }&#10;                                    .onSizeChanged { tipSize = it }   // measure so clamping is exact&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // RIGHT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LineChartPagedInternal(&#10;    modifier: Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    pageSize: Int,&#10;    // visuals&#10;    title: String,&#10;    xLabel: String,&#10;    yLabel: String,&#10;    lineColor: Color,&#10;    strokeWidth: Float,&#10;    xLabelTextSize: Float,&#10;    tooltipTextSize: Float,&#10;    interactionType: InteractionType.Line,&#10;    yAxisPosition: YAxisPosition,&#10;    yAxisFixedWidth: Dp,&#10;    showPoint: Boolean,&#10;    showValue: Boolean,&#10;    onReferenceLineClick: (() -&gt; Unit)?,&#10;    // scale/paging&#10;    unifyYAxisAcrossPages: Boolean,&#10;    yTickStep: Float?,&#10;    initialPage: Int?,&#10;    minY: Float?,&#10;    maxY: Float?&#10;) {&#10;    // how many pages&#10;    val pageCount = remember(data.size, pageSize) {&#10;        kotlin.math.ceil(data.size / pageSize.toFloat()).toInt()&#10;    }&#10;    val firstPage = initialPage ?: (pageCount - 1).coerceAtLeast(0)&#10;    val pagerState = rememberPagerState(initialPage = firstPage, pageCount = { pageCount })&#10;&#10;    // single fixed Y range for all pages (so the external axis matches)&#10;    val rawMax = if (unifyYAxisAcrossPages) data.maxOf { it.y } else data.maxOf { it.y }&#10;    val forcedMax = maxY ?: rawMax&#10;    val step = yTickStep ?: 0f&#10;    val maxRounded = remember(forcedMax, step) {&#10;        if (step &gt; 0f) (kotlin.math.ceil(forcedMax / step) * step).toFloat() else forcedMax&#10;    }&#10;&#10;    Column(modifier) {&#10;        // fixed title/header&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        Row(Modifier.fillMaxSize()) {&#10;            // left fixed axis (optional)&#10;            if (yAxisPosition == YAxisPosition.LEFT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = yTickStep,&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;&#10;            // pages area&#10;            HorizontalPager(&#10;                state = pagerState,&#10;                modifier = Modifier.weight(1f)&#10;            ) { page -&gt;&#10;                val start = page * pageSize&#10;                val end = kotlin.math.min(start + pageSize, data.size)&#10;                val slice = data.subList(start, end)&#10;&#10;                // small visual padding so the line does not touch the external axis&#10;                val padStart = if (yAxisPosition == YAxisPosition.LEFT) 12.dp else 16.dp&#10;                val padEnd   = if (yAxisPosition == YAxisPosition.RIGHT) 12.dp else 16.dp&#10;&#10;                // render a normal LineChart for this page, but:&#10;                // - no inner scroll (windowSize = null)&#10;                // - fixed external axis (fixedYAxis = true, width=0 inside)&#10;                // - unified maxY so scales match axis&#10;                LineChart(&#10;                    modifier = Modifier.fillMaxWidth().height(250.dp),&#10;                    data = slice,&#10;                    xLabel = xLabel,&#10;                    yLabel = yLabel,&#10;                    title = title,&#10;                    lineColor = lineColor,&#10;                    strokeWidth = strokeWidth,&#10;                    minY = 0f.takeIf { chartTypeForLineWantsZero() } ?: minY,&#10;                    maxY = maxRounded,&#10;                    xLabelTextSize = xLabelTextSize,&#10;                    tooltipTextSize = tooltipTextSize,&#10;                    yAxisPosition = yAxisPosition,&#10;                    interactionType = interactionType,&#10;                    showPoint = showPoint,&#10;                    showValue = showValue,&#10;                    windowSize = null,                    // no inner scroll&#10;                    chartType = ChartType.LINE,&#10;                    maxXTicksLimit = slice.size,          // show all X labels of the slice&#10;                    referenceLineType = ReferenceLineType.NONE,&#10;                    fixedYAxis = true,                    // suppress in-canvas axis&#10;                    yAxisFixedWidth = 0.dp,               // hide inner axis pane&#10;                    yTickStep = yTickStep,                // keep grid aligned with external axis&#10;                    showTitle = false,                    // title already fixed above&#10;                    contentPadding = PaddingValues(&#10;                        start = padStart,&#10;                        end = padEnd,&#10;                        top = 0.dp,&#10;                        bottom = 0.dp&#10;                    ),&#10;                    autoFixYAxisOnScroll = false,         // this page is not scrollable&#10;                    pagingEnabled = false                  // do not recurse into pager&#10;                )&#10;            }&#10;&#10;            // right fixed axis (optional)&#10;            if (yAxisPosition == YAxisPosition.RIGHT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = yTickStep,&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FixedPagerYAxisLine(&#10;    maxY: Float,&#10;    yAxisPosition: YAxisPosition,&#10;    step: Float?,&#10;    width: Dp&#10;) {&#10;    Canvas(&#10;        modifier = Modifier&#10;            .width(width)&#10;            .fillMaxHeight()&#10;    ) {&#10;        val m = ChartMath.computeMetrics(&#10;            size = size,&#10;            values = listOf(0f, maxY),&#10;            chartType = ChartType.LINE,&#10;            minY = 0f,                    // start at 0 for typical activity charts (tweak if needed)&#10;            maxY = maxY,&#10;            includeYAxisPadding = false,  // no inner side padding; this pane is just the axis&#10;            fixedTickStep = step,&#10;        )&#10;        ChartDraw.drawYAxisStandalone(&#10;            drawScope = this,&#10;            metrics = m,&#10;            yAxisPosition = yAxisPosition,&#10;            paneWidthPx = size.width&#10;        )&#10;    }&#10;}&#10;&#10;// helper so the call site reads clearly; adapt if your Line charts shouldn’t force 0&#10;private fun chartTypeForLineWantsZero(): Boolean = false&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.pager.HorizontalPager&#10;import androidx.compose.foundation.pager.rememberPagerState&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.LayoutCoordinates&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.zIndex&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartTooltip&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.core.chart.chartDraw.LineStyle&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLine&#10;import com.hdil.saluschart.core.chart.chartDraw.ReferenceLineType&#10;import com.hdil.saluschart.core.chart.chartDraw.YAxisPosition&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: Color = ChartColor.Default,&#10;    strokeWidth: Float = 4f,&#10;    minY: Float? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Float? = null,                    // 사용자 지정 최대 Y값&#10;    xLabelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    yAxisPosition: YAxisPosition = YAxisPosition.LEFT,  // Y축 위치&#10;    interactionType: InteractionType.Line = InteractionType.Line.POINT,&#10;    showPoint: Boolean = false, // 포인트 표시 여부&#10;    pointRadius: Pair&lt;Dp, Dp&gt; = Pair(4.dp, 2.dp), // 포인트 외부 반지름, 내부 반지름&#10;    showValue: Boolean = false, // 값 표시 여부&#10;    showLegend: Boolean = false,&#10;    windowSize: Int? = null, // 윈도우 크기 (null이면 전체 화면)&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    chartType : ChartType = ChartType.LINE, // 차트 타입 (툴팁 위치 결정용&#10;    maxXTicksLimit: Int? = null,             // X축에 표시할 최대 라벨 개수 (null이면 모든 라벨 표시)&#10;    referenceLineType: ReferenceLineType = ReferenceLineType.NONE,&#10;    referenceLineColor: Color = Color.Red,&#10;    referenceLineStrokeWidth: Dp = 2.dp,&#10;    referenceLineStyle: LineStyle = LineStyle.DASHED,&#10;    showReferenceLineLabel: Boolean = false,&#10;    referenceLineLabelFormat: String = &quot;평균: %.0f&quot;,&#10;    referenceLineInteractive: Boolean = false,&#10;    onReferenceLineClick: (() -&gt; Unit)? = null,&#10;&#10;    // fixed external Y-axis support&#10;    fixedYAxis: Boolean = false,&#10;    yAxisFixedWidth: Dp = 56.dp,&#10;    yTickStep: Float? = null,                    // e.g., 10f for even ticks&#10;    contentPadding: PaddingValues = PaddingValues(16.dp),&#10;    showTitle: Boolean = true,&#10;    autoFixYAxisOnScroll: Boolean = true,         // auto-fix when horizontally scrollable&#10;&#10;    pagingEnabled: Boolean = false,  // when true: use page-based swipe instead of free scroll&#10;    pageSize: Int = 0,               // items per page (e.g., 7 for a week)&#10;    unifyYAxisAcrossPages: Boolean = true,&#10;    initialPage: Int? = null,&#10;&#10;    renderTooltipExternally: Boolean = true,&#10;    unit: String = &quot;&quot;, // Added unit parameter for tooltip&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    if (pagingEnabled &amp;&amp; pageSize &gt; 0 &amp;&amp; data.size &gt; pageSize) {&#10;        LineChartPagedInternal(&#10;            modifier = modifier,&#10;            data = data,&#10;            pageSize = pageSize,&#10;            // carry over visual options&#10;            title = title,&#10;            xLabel = xLabel,&#10;            yLabel = yLabel,&#10;            lineColor = lineColor,&#10;            strokeWidth = strokeWidth,&#10;            xLabelTextSize = xLabelTextSize,&#10;            tooltipTextSize = tooltipTextSize,&#10;            interactionType = interactionType,&#10;            yAxisPosition = yAxisPosition,&#10;            yAxisFixedWidth = yAxisFixedWidth,      // external axis width&#10;            showPoint = showPoint,&#10;            showValue = showValue,&#10;            onReferenceLineClick = onReferenceLineClick,&#10;            // scale/paging options&#10;            unifyYAxisAcrossPages = unifyYAxisAcrossPages,&#10;            yTickStep = yTickStep,&#10;            initialPage = initialPage,&#10;            // we want fixed axis + no inner scroll on each page&#10;            minY = minY,&#10;            maxY = maxY&#10;        )&#10;        return&#10;    }&#10;&#10;    // windowSize 기반 스크롤 여부 결정&#10;    val useScrolling = windowSize != null &amp;&amp; windowSize &lt; data.size&#10;    val isFixedYAxis = if (autoFixYAxisOnScroll) (fixedYAxis || useScrolling) else fixedYAxis&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(modifier = modifier.padding(contentPadding)) {&#10;        if (showTitle) {&#10;            Text(title, style = MaterialTheme.typography.titleMedium)&#10;            Spacer(Modifier.height(8.dp))&#10;        }&#10;        BoxWithConstraints {&#10;            val availableWidth = maxWidth&#10;            val marginHorizontal = 16.dp&#10;&#10;            val axisGutter = if (isFixedYAxis) 2.dp else 0.dp&#10;&#10;            // paddings for the chart area (axis side gets the small gutter)&#10;            val startPad =&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT) axisGutter else marginHorizontal&#10;            val endPad =&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT) axisGutter else marginHorizontal&#10;&#10;            // width taken by the fixed Y-axis pane (left or right)&#10;            val fixedPaneWidth = if (isFixedYAxis) yAxisFixedWidth else 0.dp&#10;&#10;            // width available to the scrollable chart area (exclude axis pane + inner paddings)&#10;            val contentWidth = availableWidth - fixedPaneWidth - (startPad + endPad)&#10;&#10;            // in scroll mode, canvas spans per-window width * data size&#10;            val canvasWidth = if (useScrolling) {&#10;                val chartWidth = availableWidth - (marginHorizontal * 2)&#10;                val sectionsCount = (data.size.toFloat() / windowSize!!.toFloat()).toInt()&#10;                chartWidth * sectionsCount&#10;            } else null&#10;&#10;            val xLabels = data.map { it.label ?: it.x.toString() }&#10;            val yValues = data.map { it.y }&#10;&#10;            var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;            var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;            var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;            var chartPaneCoords by remember { mutableStateOf&lt;LayoutCoordinates?&gt;(null) }&#10;            var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;&#10;            Row(Modifier.fillMaxSize()) {&#10;&#10;                // LEFT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.LEFT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .let { if (useScrolling) it.horizontalScroll(scrollState, overscrollEffect = null) else it }&#10;                        .padding(start = startPad, end = endPad)&#10;                        .onGloballyPositioned { chartPaneCoords = it }&#10;                ) {&#10;                    Canvas(&#10;                        modifier = if (useScrolling) {&#10;                            Modifier.width(canvasWidth!!).fillMaxHeight()&#10;                        } else {&#10;                            Modifier.fillMaxSize()&#10;                        }&#10;                    ) {&#10;                        canvasSize = size&#10;                        val metrics = ChartMath.computeMetrics(&#10;                            size = size,&#10;                            values = yValues,&#10;                            chartType = ChartType.LINE,&#10;                            minY = minY,&#10;                            maxY = maxY,&#10;                            includeYAxisPadding = !isFixedYAxis,  // no inner L/R padding when fixed axis is used&#10;                            fixedTickStep = yTickStep&#10;                        )&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics, yAxisPosition, drawLabels = !isFixedYAxis)&#10;                        if (!isFixedYAxis) ChartDraw.drawYAxis(this, metrics, yAxisPosition)&#10;&#10;                        val points = ChartMath.Line.mapLineToCanvasPoints(data, size, metrics)&#10;                        canvasPoints = points&#10;                        ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                        ChartDraw.Line.drawXAxisLabels(&#10;                            ctx = drawContext,&#10;                            labels = xLabels,&#10;                            metrics = metrics,&#10;                            textSize = xLabelTextSize,&#10;                            maxXTicksLimit = maxXTicksLimit&#10;                        )&#10;&#10;                        val canvasForLabels = Size(&#10;                            width  = chartMetrics!!.paddingX + chartMetrics!!.chartWidth,&#10;                            height = chartMetrics!!.chartHeight&#10;                        )&#10;&#10;                        ChartMath.Line.computeLabelAnchors(&#10;                            points = points,&#10;                            values = yValues,&#10;                            canvas = canvasForLabels,&#10;                            textPx = with(drawContext.density) { 12.sp.toPx() },&#10;                            padPx  = with(drawContext.density) { 2.dp.toPx() },&#10;                            minGapToLinePx = with(drawContext.density) { 6.dp.toPx() },&#10;                            passes = 6,&#10;                            strokeWidthPx = strokeWidth,&#10;                            edgeMarginPx  = with(drawContext.density) { 8.dp.toPx() }&#10;                        )&#10;                    }&#10;&#10;                    // Interactions / points&#10;                    when (interactionType) {&#10;                        InteractionType.Line.TOUCH_AREA -&gt; {&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(yValues.size) { metrics.minY },&#10;                                    maxValues = yValues,&#10;                                    metrics = metrics,&#10;                                    useLineChartPositioning = true,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    isTouchArea = true,&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex&#10;                                )&#10;                            }&#10;&#10;                            // draw points/labels only when we actually know canvas size &amp; have points&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = null,&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = false,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize,&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        InteractionType.Line.POINT -&gt; {&#10;                            if (canvasSize != Size.Zero &amp;&amp; canvasPoints.isNotEmpty()) {&#10;                                ChartDraw.Scatter.PointMarker(&#10;                                    data = data,&#10;                                    points = canvasPoints,&#10;                                    values = yValues,&#10;                                    color = lineColor,&#10;                                    showPoint = showPoint,&#10;                                    selectedPointIndex = selectedPointIndex,&#10;                                    onPointClick = { index -&gt;&#10;                                        selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                                    },&#10;                                    pointRadius = pointRadius.first,&#10;                                    innerRadius = pointRadius.second,&#10;                                    interactive = true,&#10;                                    chartType = chartType,&#10;                                    showValue = showValue,&#10;                                    showTooltipForIndex = if (renderTooltipExternally) null else selectedPointIndex,&#10;                                    canvasSize = canvasSize               // ← same here&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Reference line&#10;                    if (referenceLineType != ReferenceLineType.NONE) {&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ReferenceLine.ReferenceLine(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                data = data,&#10;                                metrics = metrics,&#10;                                chartType = chartType,&#10;                                referenceLineType = referenceLineType,&#10;                                color = referenceLineColor,&#10;                                strokeWidth = referenceLineStrokeWidth,&#10;                                lineStyle = referenceLineStyle,&#10;                                showLabel = showReferenceLineLabel,&#10;                                labelFormat = referenceLineLabelFormat,&#10;                                yAxisPosition = yAxisPosition,&#10;                                interactive = referenceLineInteractive,&#10;                                onClick = onReferenceLineClick&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // ---- External tooltip overlay (top-most, with clamping) ----&#10;                    if (renderTooltipExternally &amp;&amp;&#10;                        selectedPointIndex != null &amp;&amp;&#10;                        selectedPointIndex in canvasPoints.indices&#10;                    ) {&#10;                        val i = selectedPointIndex!!&#10;                        val pt = canvasPoints[i] // canvas-space point&#10;                        val density = LocalDensity.current&#10;&#10;                        var hostSize by remember { mutableStateOf(IntSize.Zero) }&#10;                        var tipSize  by remember { mutableStateOf(IntSize.Zero) }&#10;&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .zIndex(2f)                    // above everything in this Box&#10;                                .onSizeChanged { hostSize = it }&#10;                        ) {&#10;                            val pad = with(density) { 8.dp.toPx() }&#10;&#10;                            // desired position: to the right and above the point&#10;                            val desiredX = pt.x + pad&#10;                            val desiredYAbove = pt.y - pad - tipSize.height&#10;&#10;                            // if there isn't room above, place it below the point&#10;                            val yPlaced = if (desiredYAbove &lt; 0f) (pt.y + pad)&#10;                            else desiredYAbove&#10;&#10;                            // clamp inside the host box on both axes&#10;                            val maxX = (hostSize.width  - tipSize.width ).coerceAtLeast(0)&#10;                            val maxY = (hostSize.height - tipSize.height).coerceAtLeast(0)&#10;                            val xClamped = desiredX.coerceIn(0f, maxX.toFloat())&#10;                            val yClamped = yPlaced.coerceIn(0f, maxY.toFloat())&#10;&#10;                            ChartTooltip(&#10;                                chartPoint = data[i],&#10;                                unit = unit,&#10;                                modifier = Modifier&#10;                                    .offset { IntOffset(xClamped.toInt(), yClamped.toInt()) }&#10;                                    .onSizeChanged { tipSize = it }   // measure so clamping is exact&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // RIGHT fixed Y-axis pane&#10;                if (isFixedYAxis &amp;&amp; yAxisPosition == YAxisPosition.RIGHT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                    Canvas(&#10;                        modifier = Modifier&#10;                            .width(yAxisFixedWidth)&#10;                            .fillMaxHeight()&#10;                    ) {&#10;                        chartMetrics?.let { m -&gt;&#10;                            ChartDraw.drawYAxisStandalone(&#10;                                drawScope = this,&#10;                                metrics = m,&#10;                                yAxisPosition = yAxisPosition,&#10;                                paneWidthPx = size.width&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LineChartPagedInternal(&#10;    modifier: Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    pageSize: Int,&#10;    // visuals&#10;    title: String,&#10;    xLabel: String,&#10;    yLabel: String,&#10;    lineColor: Color,&#10;    strokeWidth: Float,&#10;    xLabelTextSize: Float,&#10;    tooltipTextSize: Float,&#10;    interactionType: InteractionType.Line,&#10;    yAxisPosition: YAxisPosition,&#10;    yAxisFixedWidth: Dp,&#10;    showPoint: Boolean,&#10;    showValue: Boolean,&#10;    onReferenceLineClick: (() -&gt; Unit)?,&#10;    // scale/paging&#10;    unifyYAxisAcrossPages: Boolean,&#10;    yTickStep: Float?,&#10;    initialPage: Int?,&#10;    minY: Float?,&#10;    maxY: Float?&#10;) {&#10;    // how many pages&#10;    val pageCount = remember(data.size, pageSize) {&#10;        kotlin.math.ceil(data.size / pageSize.toFloat()).toInt()&#10;    }&#10;    val firstPage = initialPage ?: (pageCount - 1).coerceAtLeast(0)&#10;    val pagerState = rememberPagerState(initialPage = firstPage, pageCount = { pageCount })&#10;&#10;    // single fixed Y range for all pages (so the external axis matches)&#10;    val rawMax = if (unifyYAxisAcrossPages) data.maxOf { it.y } else data.maxOf { it.y }&#10;    val forcedMax = maxY ?: rawMax&#10;    val step = yTickStep ?: 0f&#10;    val maxRounded = remember(forcedMax, step) {&#10;        if (step &gt; 0f) (kotlin.math.ceil(forcedMax / step) * step).toFloat() else forcedMax&#10;    }&#10;&#10;    Column(modifier) {&#10;        // fixed title/header&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        Row(Modifier.fillMaxSize()) {&#10;            // left fixed axis (optional)&#10;            if (yAxisPosition == YAxisPosition.LEFT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = yTickStep,&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;&#10;            // pages area&#10;            HorizontalPager(&#10;                state = pagerState,&#10;                modifier = Modifier.weight(1f)&#10;            ) { page -&gt;&#10;                val start = page * pageSize&#10;                val end = kotlin.math.min(start + pageSize, data.size)&#10;                val slice = data.subList(start, end)&#10;&#10;                // small visual padding so the line does not touch the external axis&#10;                val padStart = if (yAxisPosition == YAxisPosition.LEFT) 12.dp else 16.dp&#10;                val padEnd   = if (yAxisPosition == YAxisPosition.RIGHT) 12.dp else 16.dp&#10;&#10;                // render a normal LineChart for this page, but:&#10;                // - no inner scroll (windowSize = null)&#10;                // - fixed external axis (fixedYAxis = true, width=0 inside)&#10;                // - unified maxY so scales match axis&#10;                LineChart(&#10;                    modifier = Modifier.fillMaxWidth().height(250.dp),&#10;                    data = slice,&#10;                    xLabel = xLabel,&#10;                    yLabel = yLabel,&#10;                    title = title,&#10;                    lineColor = lineColor,&#10;                    strokeWidth = strokeWidth,&#10;                    minY = 0f.takeIf { chartTypeForLineWantsZero() } ?: minY,&#10;                    maxY = maxRounded,&#10;                    xLabelTextSize = xLabelTextSize,&#10;                    tooltipTextSize = tooltipTextSize,&#10;                    yAxisPosition = yAxisPosition,&#10;                    interactionType = interactionType,&#10;                    showPoint = showPoint,&#10;                    showValue = showValue,&#10;                    windowSize = null,                    // no inner scroll&#10;                    chartType = ChartType.LINE,&#10;                    maxXTicksLimit = slice.size,          // show all X labels of the slice&#10;                    referenceLineType = ReferenceLineType.NONE,&#10;                    fixedYAxis = true,                    // suppress in-canvas axis&#10;                    yAxisFixedWidth = 0.dp,               // hide inner axis pane&#10;                    yTickStep = yTickStep,                // keep grid aligned with external axis&#10;                    showTitle = false,                    // title already fixed above&#10;                    contentPadding = PaddingValues(&#10;                        start = padStart,&#10;                        end = padEnd,&#10;                        top = 0.dp,&#10;                        bottom = 0.dp&#10;                    ),&#10;                    autoFixYAxisOnScroll = false,         // this page is not scrollable&#10;                    pagingEnabled = false                  // do not recurse into pager&#10;                )&#10;            }&#10;&#10;            // right fixed axis (optional)&#10;            if (yAxisPosition == YAxisPosition.RIGHT &amp;&amp; yAxisFixedWidth &gt; 0.dp) {&#10;                FixedPagerYAxisLine(&#10;                    maxY = maxRounded,&#10;                    yAxisPosition = yAxisPosition,&#10;                    step = yTickStep,&#10;                    width = yAxisFixedWidth&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FixedPagerYAxisLine(&#10;    maxY: Float,&#10;    yAxisPosition: YAxisPosition,&#10;    step: Float?,&#10;    width: Dp&#10;) {&#10;    Canvas(&#10;        modifier = Modifier&#10;            .width(width)&#10;            .fillMaxHeight()&#10;    ) {&#10;        val m = ChartMath.computeMetrics(&#10;            size = size,&#10;            values = listOf(0f, maxY),&#10;            chartType = ChartType.LINE,&#10;            minY = 0f,                    // start at 0 for typical activity charts (tweak if needed)&#10;            maxY = maxY,&#10;            includeYAxisPadding = false,  // no inner side padding; this pane is just the axis&#10;            fixedTickStep = step,&#10;        )&#10;        ChartDraw.drawYAxisStandalone(&#10;            drawScope = this,&#10;            metrics = m,&#10;            yAxisPosition = yAxisPosition,&#10;            paneWidthPx = size.width&#10;        )&#10;    }&#10;}&#10;&#10;// helper so the call site reads clearly; adapt if your Line charts shouldn’t force 0&#10;private fun chartTypeForLineWantsZero(): Boolean = false" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>