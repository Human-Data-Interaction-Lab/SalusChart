<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/build.gradle.kts" />
              <option name="originalContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;    implementation(project(&quot;:data:model&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;    implementation(libs.androidx.foundation.layout)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;&#10;    // compose shape&#10;    implementation(&quot;androidx.graphics:graphics-shapes:1.0.1&quot;)&#10;}" />
              <option name="updatedContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;    implementation(project(&quot;:data:model&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;    implementation(libs.androidx.foundation.layout)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;&#10;    // compose shape&#10;    implementation(&quot;androidx.graphics:graphics-shapes:1.0.1&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * Y축 위치를 나타내는 열거형 클래스&#10; */&#10;enum class YAxisPosition {&#10;    LEFT,   // 왼쪽&#10;    RIGHT   // 오른쪽&#10;}&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT, drawLabels: Boolean = true) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            // Convert chart-relative Y to canvas coordinates&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = metrics.paddingX // 왼쪽 Y축까지&#10;            val gridEnd = when (yAxisPosition) {&#10;                YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                YAxisPosition.LEFT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            // only draw labels when drawLabels = true&#10;            if (drawLabels) {&#10;                val labelText = formatTickLabel(yVal)&#10;&#10;                // Y축 레이블 위치를 yAxisPosition에 따라 결정&#10;                val labelX = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; yAxisX + 20f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                    YAxisPosition.LEFT -&gt; 20f // 기본값: 왼쪽 위치&#10;                }&#10;&#10;                // Y축 레이블 정렬을 yAxisPosition에 따라 결정&#10;                val textAlign = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; android.graphics.Paint.Align.LEFT // 오른쪽 Y축일 때는 왼쪽 정렬&#10;                    YAxisPosition.LEFT -&gt; android.graphics.Paint.Align.RIGHT // 왼쪽 Y축일 때는 오른쪽 정렬&#10;                }&#10;&#10;                drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                    labelText,&#10;                    labelX,&#10;                    y + 10f,&#10;                    android.graphics.Paint().apply {&#10;                        color = android.graphics.Color.DKGRAY&#10;                        textSize = 28f&#10;                        this.textAlign = textAlign&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.paddingY + metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT) {&#10;        // Y축 라인 위치를 yAxisPosition에 따라 결정&#10;        val axisStartX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, metrics.paddingY),&#10;            end = Offset(axisStartX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    fun drawYAxisStandalone(&#10;        drawScope: DrawScope,&#10;        metrics: ChartMath.ChartMetrics,&#10;        yAxisPosition: YAxisPosition,&#10;        paneWidthPx: Float,&#10;        labelTextSizePx: Float = 28f&#10;    ) {&#10;        // Axis X anchored to the pane edge (1px in from the edge)&#10;        val axisX = if (yAxisPosition == YAxisPosition.RIGHT) paneWidthPx - 0.5f else 0.5f&#10;&#10;        // Axis line&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisX, metrics.paddingY),&#10;            end = Offset(axisX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;&#10;        // Ticks &amp; labels&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // small tick mark&#10;            val tickLen = 8f&#10;            val tickStartX = if (yAxisPosition == YAxisPosition.RIGHT) axisX else axisX&#10;            val tickEndX = if (yAxisPosition == YAxisPosition.RIGHT) axisX - tickLen else axisX + tickLen&#10;            drawScope.drawLine(&#10;                color = Color.DarkGray,&#10;                start = Offset(tickStartX, y),&#10;                end = Offset(tickEndX, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            val label = formatTickLabel(yVal)&#10;            val paint = android.graphics.Paint().apply {&#10;                isAntiAlias = true&#10;                color = android.graphics.Color.DKGRAY&#10;                textSize = labelTextSizePx&#10;                textAlign = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                    android.graphics.Paint.Align.LEFT else android.graphics.Paint.Align.RIGHT&#10;            }&#10;            val labelX = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                axisX + 10f else axisX - 10f&#10;&#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(label, labelX, y + 10f, paint)&#10;        }&#10;    }&#10;&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * Y축 위치를 나타내는 열거형 클래스&#10; */&#10;enum class YAxisPosition {&#10;    LEFT,   // 왼쪽&#10;    RIGHT   // 오른쪽&#10;}&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT, drawLabels: Boolean = true) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            // Convert chart-relative Y to canvas coordinates&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = metrics.paddingX // 왼쪽 Y축까지&#10;            val gridEnd = when (yAxisPosition) {&#10;                YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                YAxisPosition.LEFT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            // only draw labels when drawLabels = true&#10;            if (drawLabels) {&#10;                val labelText = formatTickLabel(yVal)&#10;&#10;                // Y축 레이블 위치를 yAxisPosition에 따라 결정&#10;                val labelX = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; yAxisX + 20f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                    YAxisPosition.LEFT -&gt; 20f // 기본값: 왼쪽 위치&#10;                }&#10;&#10;                // Y축 레이블 정렬을 yAxisPosition에 따라 결정&#10;                val textAlign = when (yAxisPosition) {&#10;                    YAxisPosition.RIGHT -&gt; android.graphics.Paint.Align.LEFT // 오른쪽 Y축일 때는 왼쪽 정렬&#10;                    YAxisPosition.LEFT -&gt; android.graphics.Paint.Align.RIGHT // 왼쪽 Y축일 때는 오른쪽 정렬&#10;                }&#10;&#10;                drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                    labelText,&#10;                    labelX,&#10;                    y + 10f,&#10;                    android.graphics.Paint().apply {&#10;                        color = android.graphics.Color.DKGRAY&#10;                        textSize = 28f&#10;                        this.textAlign = textAlign&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.paddingY + metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yAxisPosition Y축 위치&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yAxisPosition: YAxisPosition = YAxisPosition.LEFT) {&#10;        // Y축 라인 위치를 yAxisPosition에 따라 결정&#10;        val axisStartX = when (yAxisPosition) {&#10;            YAxisPosition.RIGHT -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            YAxisPosition.LEFT -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, metrics.paddingY),&#10;            end = Offset(axisStartX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    fun drawYAxisStandalone(&#10;        drawScope: DrawScope,&#10;        metrics: ChartMath.ChartMetrics,&#10;        yAxisPosition: YAxisPosition,&#10;        paneWidthPx: Float,&#10;        labelTextSizePx: Float = 28f&#10;    ) {&#10;        // Axis X anchored to the pane edge (1px in from the edge)&#10;        val axisX = if (yAxisPosition == YAxisPosition.RIGHT) paneWidthPx - 0.5f else 0.5f&#10;&#10;        // Axis line&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisX, metrics.paddingY),&#10;            end = Offset(axisX, metrics.paddingY + metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;&#10;        // Ticks &amp; labels&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.paddingY + metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // small tick mark&#10;            val tickLen = 8f&#10;            val tickStartX = if (yAxisPosition == YAxisPosition.RIGHT) axisX else axisX&#10;            val tickEndX = if (yAxisPosition == YAxisPosition.RIGHT) axisX - tickLen else axisX + tickLen&#10;            drawScope.drawLine(&#10;                color = Color.DarkGray,&#10;                start = Offset(tickStartX, y),&#10;                end = Offset(tickEndX, y),&#10;                strokeWidth = 1f&#10;            )&#10;&#10;            val label = formatTickLabel(yVal)&#10;            val paint = android.graphics.Paint().apply {&#10;                isAntiAlias = true&#10;                color = android.graphics.Color.DKGRAY&#10;                textSize = labelTextSizePx&#10;                textAlign = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                    android.graphics.Paint.Align.LEFT else android.graphics.Paint.Align.RIGHT&#10;            }&#10;            val labelX = if (yAxisPosition == YAxisPosition.RIGHT)&#10;                axisX + 10f else axisX - 10f&#10;&#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(label, labelX, y + 10f, paint)&#10;        }&#10;    }&#10;&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/SleepStageChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/SleepStageChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.chartMath.SleepStageChartMath&#10;&#10;object SleepStageChartDraw {&#10;    &#10;    /**&#10;     * 수평 바 차트의 바들을 Composable로 생성합니다.&#10;     * 수면 단계 차트와 같은 수평 바 차트에 사용됩니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param minValues 바의 최소값 목록 (X축 방향의 시작값)&#10;     * @param maxValues 바의 최대값 목록 (X축 방향의 끝값)&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상 (단일 바용)&#10;     * @param barHeightRatio 바 높이 배수 (기본값: 0.8f)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 툴팁 텍스트)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     * @param showTooltipForIndex 외부에서 제어되는 툴팁 표시 인덱스 (null이면 표시 안함)&#10;     * @param isTouchArea true이면 터치 영역용 (투명, 전체 너비, 상호작용 가능), false이면 일반 바 (기본값: false)&#10;     * @param customTooltipText 커스텀 툴팁 텍스트 목록 (null이면 기본 툴팁 사용)&#10;     * @param showLabel 라벨 표시 여부 (기본값: false)&#10;     * @param unit 단위 (기본값: &quot;&quot;)&#10;     */&#10;    @Composable&#10;    fun HorizontalBarMarker(&#10;        data: List&lt;BaseChartPoint&gt;,&#10;        minValues: List&lt;Float&gt;,&#10;        maxValues: List&lt;Float&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        color: Color = Color.Black,&#10;        barHeightRatio: Float = 0.5f,&#10;        interactive: Boolean = true,&#10;        onBarClick: ((Int, String) -&gt; Unit)? = null,&#10;        chartType: ChartType,&#10;        showTooltipForIndex: Int? = null,&#10;        isTouchArea: Boolean = false,&#10;        customTooltipText: List&lt;String&gt;? = null,&#10;//        showLabel: Boolean = false,  &lt;- SleepStage에서는 필요없음, ProgressBar에서 사용&#10;        unit: String = &quot;&quot;,&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        // 터치 영역용인 경우 자동으로 파라미터 설정&#10;        val actualBarHeightRatio = if (isTouchArea) 1.0f else barHeightRatio&#10;        val actualInteractive = if (isTouchArea) true else interactive&#10;&#10;        val dataSize = maxOf(minValues.size, maxValues.size)&#10;&#10;        // 클릭된 바의 인덱스를 관리하는 상태 변수&#10;        var clickedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;        // 툴팁 정보 저장 변수&#10;        var tooltipOffset: Offset? = null&#10;        var tooltipData: BaseChartPoint? = null&#10;&#10;        (0 until dataSize).forEach { index -&gt;&#10;            // 값 추출&#10;            val minValue = minValues.getOrNull(index) ?: 0f&#10;            val maxValue = maxValues.getOrNull(index) ?: 0f&#10;&#10;            // tooltipText is only used for onBarClick callback&#10;            val tooltipText = customTooltipText?.getOrNull(index) ?: &quot;Sleep Stage&quot;&#10;&#10;            // 바 너비와 위치 계산 (수평이므로 X축 방향으로 계산)&#10;            val (barWidth, barX) = if (isTouchArea) {&#10;                // 전체 차트 너비 사용 (터치 영역용)&#10;                Pair(metrics.chartWidth, metrics.paddingX)&#10;            } else {&#10;                // minValue에서 maxValue까지의 바 계산 (X축 방향)&#10;                val xMinScreen = ((minValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val xMaxScreen = ((maxValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val width = xMaxScreen - xMinScreen&#10;                // Add paddingX to position bars correctly within the chart area&#10;                Pair(width, metrics.paddingX + xMinScreen)&#10;            }&#10;&#10;            // 바 Y 위치 계산 (수평이므로 Y축은 sleep stage ordinal 기반)&#10;            val sleepStageOrdinal = data.getOrNull(index)?.x?.toInt() ?: 0&#10;            val totalSleepStages = 4 // AWAKE, REM, LIGHT, DEEP&#10;            val spacing = metrics.chartHeight / totalSleepStages&#10;            val barHeight = spacing * actualBarHeightRatio&#10;            val barY = metrics.paddingY + sleepStageOrdinal * spacing + (spacing - barHeight) / 2f&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val barXDp = with(density) { barX.toDp() }&#10;            val barYDp = with(density) { barY.toDp() }&#10;            val barWidthDp = with(density) { barWidth.toDp() }&#10;            val barHeightDp = with(density) { barHeight.toDp() }&#10;&#10;            // 툴팁 표시 여부 결정&#10;            val shouldShowTooltip = when {&#10;                isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                chartType in listOf(ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                    if (actualInteractive) {&#10;                        clickedBarIndex == index&#10;                    } else {&#10;                        showTooltipForIndex == index&#10;                    }&#10;                }&#10;                else -&gt; false // 다른 차트 타입에서는 툴팁 표시 안함&#10;            }&#10;&#10;            if (shouldShowTooltip) {&#10;                tooltipData = data[index]&#10;                tooltipOffset = Offset(barX, barY)&#10;            }&#10;&#10;            val actualColor = if (isTouchArea) {&#10;                Color.Transparent // 터치 영역용은 투명&#10;            } else {&#10;                if (actualInteractive) {&#10;                    if (clickedBarIndex == index || clickedBarIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                } else {&#10;                    if (showTooltipForIndex == index || showTooltipForIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                }&#10;            }&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .offset(x = barXDp, y = barYDp)&#10;                    .size(width = barWidthDp, height = barHeightDp)&#10;                    .background(color = actualColor)&#10;                    .clickable {&#10;                        if (actualInteractive) {&#10;                            // 클릭된 바 인덱스 토글&#10;                            clickedBarIndex = if (clickedBarIndex == index) null else index&#10;                            // 외부 클릭 이벤트 처리&#10;                            onBarClick?.invoke(index, tooltipText)&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;        &#10;        // 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;        if (tooltipData != null &amp;&amp; tooltipOffset != null) {&#10;            val xDp = with(density) { tooltipOffset.x.toDp() }&#10;            val yDp = with(density) { tooltipOffset.y.toDp() }&#10;            &#10;            // Generate custom tooltip text for sleep stage charts&#10;            val customTooltipText = if (tooltipData is RangeChartPoint) {&#10;                val sleepStageOrdinal = tooltipData.x.toInt()&#10;                val sleepStageName = when (sleepStageOrdinal) {&#10;                    0 -&gt; &quot;Awake&quot;&#10;                    1 -&gt; &quot;REM&quot;&#10;                    2 -&gt; &quot;Light&quot;&#10;                    3 -&gt; &quot;Deep&quot;&#10;                    else -&gt; &quot;Unknown&quot;&#10;                }&#10;                val startTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.minPoint.y)&#10;                val endTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.maxPoint.y)&#10;                &quot;$startTime - $endTime&quot;&#10;            } else null&#10;            &#10;            ChartTooltip(&#10;                chartPoint = tooltipData,&#10;                unit = unit,&#10;                customText = customTooltipText,&#10;                modifier = Modifier.offset(x = xDp, y = yDp - 80.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.onGloballyPositioned&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.chartMath.SleepStageChartMath&#10;&#10;object SleepStageChartDraw {&#10;    &#10;    /**&#10;     * 수평 바 차트의 바들을 Composable로 생성합니다.&#10;     * 수면 단계 차트와 같은 수평 바 차트에 사용됩니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param minValues 바의 최소값 목록 (X축 방향의 시작값)&#10;     * @param maxValues 바의 최대값 목록 (X축 방향의 끝값)&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상 (단일 바용)&#10;     * @param barHeightRatio 바 높이 배수 (기본값: 0.8f)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 툴팁 텍스트)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     * @param showTooltipForIndex 외부에서 제어되는 툴팁 표시 인덱스 (null이면 표시 안함)&#10;     * @param isTouchArea true이면 터치 영역용 (투명, 전체 너비, 상호작용 가능), false이면 일반 바 (기본값: false)&#10;     * @param customTooltipText 커스텀 툴팁 텍스트 목록 (null이면 기본 툴팁 사용)&#10;     * @param showLabel 라벨 표시 여부 (기본값: false)&#10;     * @param unit 단위 (기본값: &quot;&quot;)&#10;     */&#10;    @Composable&#10;    fun HorizontalBarMarker(&#10;        data: List&lt;BaseChartPoint&gt;,&#10;        minValues: List&lt;Float&gt;,&#10;        maxValues: List&lt;Float&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        color: Color = Color.Black,&#10;        barHeightRatio: Float = 0.5f,&#10;        interactive: Boolean = true,&#10;        onBarClick: ((Int, String) -&gt; Unit)? = null,&#10;        chartType: ChartType,&#10;        showTooltipForIndex: Int? = null,&#10;        isTouchArea: Boolean = false,&#10;        customTooltipText: List&lt;String&gt;? = null,&#10;//        showLabel: Boolean = false,  &lt;- SleepStage에서는 필요없음, ProgressBar에서 사용&#10;        unit: String = &quot;&quot;,&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        // 터치 영역용인 경우 자동으로 파라미터 설정&#10;        val actualBarHeightRatio = if (isTouchArea) 1.0f else barHeightRatio&#10;        val actualInteractive = if (isTouchArea) true else interactive&#10;&#10;        val dataSize = maxOf(minValues.size, maxValues.size)&#10;&#10;        // 클릭된 바의 인덱스를 관리하는 상태 변수&#10;        var clickedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;        // 툴팁 정보 저장 변수&#10;        var tooltipOffset: Offset? = null&#10;        var tooltipData: BaseChartPoint? = null&#10;&#10;        (0 until dataSize).forEach { index -&gt;&#10;            // 값 추출&#10;            val minValue = minValues.getOrNull(index) ?: 0f&#10;            val maxValue = maxValues.getOrNull(index) ?: 0f&#10;&#10;            // tooltipText is only used for onBarClick callback&#10;            val tooltipText = customTooltipText?.getOrNull(index) ?: &quot;Sleep Stage&quot;&#10;&#10;            // 바 너비와 위치 계산 (수평이므로 X축 방향으로 계산)&#10;            val (barWidth, barX) = if (isTouchArea) {&#10;                // 전체 차트 너비 사용 (터치 영역용)&#10;                Pair(metrics.chartWidth, metrics.paddingX)&#10;            } else {&#10;                // minValue에서 maxValue까지의 바 계산 (X축 방향)&#10;                val xMinScreen = ((minValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val xMaxScreen = ((maxValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartWidth&#10;                val width = xMaxScreen - xMinScreen&#10;                // Add paddingX to position bars correctly within the chart area&#10;                Pair(width, metrics.paddingX + xMinScreen)&#10;            }&#10;&#10;            // 바 Y 위치 계산 (수평이므로 Y축은 sleep stage ordinal 기반)&#10;            val sleepStageOrdinal = data.getOrNull(index)?.x?.toInt() ?: 0&#10;            val totalSleepStages = 4 // AWAKE, REM, LIGHT, DEEP&#10;            val spacing = metrics.chartHeight / totalSleepStages&#10;            val barHeight = spacing * actualBarHeightRatio&#10;            val barY = metrics.paddingY + sleepStageOrdinal * spacing + (spacing - barHeight) / 2f&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val barXDp = with(density) { barX.toDp() }&#10;            val barYDp = with(density) { barY.toDp() }&#10;            val barWidthDp = with(density) { barWidth.toDp() }&#10;            val barHeightDp = with(density) { barHeight.toDp() }&#10;&#10;            // 툴팁 표시 여부 결정&#10;            val shouldShowTooltip = when {&#10;                isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                chartType in listOf(ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                    if (actualInteractive) {&#10;                        clickedBarIndex == index&#10;                    } else {&#10;                        showTooltipForIndex == index&#10;                    }&#10;                }&#10;                else -&gt; false // 다른 차트 타입에서는 툴팁 표시 안함&#10;            }&#10;&#10;            if (shouldShowTooltip) {&#10;                tooltipData = data[index]&#10;                tooltipOffset = Offset(barX, barY)&#10;            }&#10;&#10;            val actualColor = if (isTouchArea) {&#10;                Color.Transparent // 터치 영역용은 투명&#10;            } else {&#10;                if (actualInteractive) {&#10;                    if (clickedBarIndex == index || clickedBarIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                } else {&#10;                    if (showTooltipForIndex == index || showTooltipForIndex == null) {&#10;                        color&#10;                    } else {&#10;                        color.copy(alpha = 0.3f) // 클릭되지 않은 바는 반투명 처리&#10;                    }&#10;                }&#10;            }&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .offset(x = barXDp, y = barYDp)&#10;                    .size(width = barWidthDp, height = barHeightDp)&#10;                    .background(color = actualColor)&#10;                    .clickable {&#10;                        if (actualInteractive) {&#10;                            // 클릭된 바 인덱스 토글&#10;                            clickedBarIndex = if (clickedBarIndex == index) null else index&#10;                            // 외부 클릭 이벤트 처리&#10;                            onBarClick?.invoke(index, tooltipText)&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;        &#10;        // 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;        if (tooltipData != null &amp;&amp; tooltipOffset != null) {&#10;            val xDp = with(density) { tooltipOffset.x.toDp() }&#10;            val yDp = with(density) { tooltipOffset.y.toDp() }&#10;            &#10;            // Generate custom tooltip text for sleep stage charts&#10;            val customTooltipText = if (tooltipData is RangeChartPoint) {&#10;                val sleepStageOrdinal = tooltipData.x.toInt()&#10;                val sleepStageName = when (sleepStageOrdinal) {&#10;                    0 -&gt; &quot;Awake&quot;&#10;                    1 -&gt; &quot;REM&quot;&#10;                    2 -&gt; &quot;Light&quot;&#10;                    3 -&gt; &quot;Deep&quot;&#10;                    else -&gt; &quot;Unknown&quot;&#10;                }&#10;                val startTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.minPoint.y)&#10;                val endTime = SleepStageChartMath.formatTimeFromMilliseconds(tooltipData.maxPoint.y)&#10;                &quot;$startTime - $endTime&quot;&#10;            } else null&#10;            &#10;            ChartTooltip(&#10;                chartPoint = tooltipData,&#10;                unit = unit,&#10;                customText = customTooltipText,&#10;                modifier = Modifier.offset(x = xDp, y = yDp - 80.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>