package com.hdil.saluschart.core.chart.chartMath

import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import com.hdil.saluschart.core.chart.ProgressChartMark
import kotlin.math.cos
import kotlin.math.sin

/**
 * Math utilities for progress charts (donut rings and bar-style progress rows).
 *
 * This object is responsible for:
 * - Computing donut chart center/radii for multiple rings
 * - Computing label/value anchor positions for donut and bar modes
 *
 * Notes:
 * - Many values here are pixel-based constants (padding, offsets). They are kept as-is to
 *   preserve existing visuals and behavior.
 */
object ProgressChartMath {

    /**
     * Computes donut-ring geometry for a multi-ring progress chart.
     *
     * Rings are computed from the outside toward the inside. For each item in [data], a radius is
     * generated by subtracting `(strokeWidth + ringSpacing) * index` from [maxRadius].
     * A ring is only included if it can still fit at least half the stroke width.
     *
     * @param size Canvas size.
     * @param data Progress chart data list (determines ring count).
     * @param padding Outer padding between the donut and canvas bounds (px).
     * @param strokeWidth Ring thickness (px).
     * @param ringSpacing Spacing between rings (px).
     * @return Triple(center, maxRadius, ringRadii).
     */
    fun computeProgressDonutMetrics(
        size: Size,
        data: List<ProgressChartMark>,
        padding: Float = 32f,
        strokeWidth: Float = 40f,
        ringSpacing: Float = 8f
    ): Triple<Offset, Float, List<Float>> {
        val center = Offset(size.width / 2f, size.height / 2f)
        val maxRadius = minOf(size.width, size.height) / 2 - padding

        val ringRadii = mutableListOf<Float>()
        val instanceCount = data.size

        for (i in 0 until instanceCount) {
            val ringRadius = maxRadius - (i * (strokeWidth + ringSpacing))
            if (ringRadius > strokeWidth / 2) {
                ringRadii.add(ringRadius)
            }
        }

        return Triple(center, maxRadius, ringRadii)
    }

    /**
     * Computes the anchor position for a progress label.
     *
     * Donut mode:
     * - Places the label near the start angle (-90°, 12 o'clock) on the inner edge of the ring
     *   (`radius - strokeWidth/2`).
     *
     * Bar mode:
     * - Places the label to the left of the bar.
     *
     * Note: [point] is currently unused by the existing implementation but is kept for API stability.
     *
     * @param center Center point (canvas coordinates).
     * @param radius Ring radius (donut mode).
     * @param isDonut Whether the chart is donut mode.
     * @param point Progress item (kept for signature stability; not used here).
     * @param strokeWidth Ring thickness (donut mode).
     * @param barY Top Y of the bar row (bar mode).
     * @param barWidth Total bar width (bar mode).
     * @return Label anchor position.
     */
    fun computeLabelPosition(
        center: Offset,
        radius: Float = 0f,
        isDonut: Boolean,
        point: ProgressChartMark,
        strokeWidth: Float = 40f,
        barY: Float = 0f,
        barWidth: Float = 0f
    ): Offset {
        return if (isDonut) {
            val startAngle = -90f
            val startAngleRadians = Math.toRadians(startAngle.toDouble())

            val labelRadius = radius - (strokeWidth / 2f)
            val x = center.x + (labelRadius * cos(startAngleRadians)).toFloat()
            val y = center.y + (labelRadius * sin(startAngleRadians)).toFloat()

            Offset(x, y)
        } else {
            Offset(center.x - barWidth / 2f - 20f, barY + 15f)
        }
    }

    /**
     * Computes the anchor position for a progress value text.
     *
     * Donut mode:
     * - Places the value near the end of the progress arc at radius `radius + 15`.
     * - Uses `point.progress * 360` degrees starting from -90°.
     *
     * Bar mode:
     * - Places the value to the right of the bar.
     *
     * @param center Center point (canvas coordinates).
     * @param radius Ring radius (donut mode).
     * @param isDonut Whether the chart is donut mode.
     * @param point Progress item (uses [ProgressChartMark.progress] in donut mode).
     * @param barY Top Y of the bar row (bar mode).
     * @param barWidth Total bar width (bar mode).
     * @return Value anchor position.
     */
    fun computeValuePosition(
        center: Offset,
        radius: Float = 0f,
        isDonut: Boolean,
        point: ProgressChartMark,
        barY: Float = 0f,
        barWidth: Float = 0f
    ): Offset {
        return if (isDonut) {
            val startAngle = -90f
            val sweepAngle = point.progress * 360f
            val endAngle = startAngle + sweepAngle

            val endAngleRadians = Math.toRadians(endAngle.toDouble())

            val textRadius = radius + 15f
            val x = center.x + (textRadius * cos(endAngleRadians)).toFloat()
            val y = center.y + (textRadius * sin(endAngleRadians)).toFloat()

            Offset(x, y)
        } else {
            Offset(center.x + barWidth / 2f + 20f, barY + 15f)
        }
    }
}